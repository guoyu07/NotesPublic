|!!|
1 nibble = 4 bits
1 byte = 2 nibble = 8 bits
1 word = DataBus = 64(in-64bit-sys) 32(in-32bit-sys) 16(in-16bit-sys)  
32/64-bit Compiler
  sizeof(char) = 1 byte = 8 bit
  sizeof(short int) = 2 bytes
  sizeof(int) = 4 bytes
  sizeof(unsigned int) = 4 bytes
  sizeof(float) = 4 bytes
  sizeof(double) = 8 bytes
  sizeof(long long) = 8 bytes
32-bit Compiler
  sizeof(char*) = 4 bytes = 32 bit
  sizeof(long) = 4 bytes
  sizeof(unsigned long) = 4 bytes
64-bit Compiler
  sizeof(char *) = 8 bytes = 64 bit
  sizeof(long) = 8 bytes
  sizeof(unsinged long) = 8 bytes
|+ Bitwise Negative Number +|
1 = 0000 0001  ~1 = 1111 1110    ~1 + 1 = 1111 1111  = -1
  ~1 = 1111 1110    ~1 - 1 = 1111 1101  ~(~1 - 1) = 0000 0010 = 2
     = -2
3 = 0000 0011  ~3 = 1111 1100    ~3 + 1 = 1111 1101  = -1
  ~3 = 1111 1100    ~3 - 1 = 1111 1011 ~(~3 - 1) = 0000 0100 = 4
     = -4

|- Bitwise Operators -|
/**
 * bitwise operator name(sign) -> operation performance in each bit
 */
bitwise NOT(~) -> logical negation:         ~7      ==>  !0111 = 1000 = 8
bitwise AND(&) -> logical AND:              7 & 8   ==>  0111 & 1000 = 0
bitwise OR(|)  -> logical inclusive OR:     6 | 12  ==>  0110 | 1100 = 1110 = 14
bitwise XOR(^) -> logical exclusive OR:     6 ^ 12  ==>  0110 ^ 1100 = 0001 = 1

/**
 * Get the sizeof(n) that should be n times of sizeof(int)
 */
#define _INITSIZEOF(n) ((int)ceil((double)sizeof(n)/sizeof(int)) * sizeof(int))
/**
 * sizeof(int) = 4 = 2**2  any 1 in bit before 4 will be multiple of 4.
 *  e.g. `100` = 4   `1000` = 8   `10000` = 16
 *  Get sizeof(n) + sizeof(int) then do logical AND with `11`
 */
#define _INITSIZEOF(n) ((sizeof(n) + sizeof(int) - 1)&~(sizeof(int) - 1))
#define CMSG_ALIGN(len) ((len + sizeof(size_t) - 1) & (size_t)~(sizeof(size_t) -1)) 
|- Bit Shifts -|
right shift(>>):                            12>>2   ==>  1100>>2 = 0011 = 3
left shift(<<):                             12<<2   ==>  1100<<2 = 110000 = 48