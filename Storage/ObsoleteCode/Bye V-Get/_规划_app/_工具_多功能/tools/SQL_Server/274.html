<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>信息挖掘初步（ccat）</B><BR><IMG 
src="http://www.pigtwo.com/forum/pic/url.gif" align=absMiddle border=0><A 
href="http://www.csdn.net/develop/read_article.asp?id=14081" 
target=_blank>http://www.csdn.net/develop/read_article.asp?id=14081</A><BR>写这本书的最初想法，来自于在第一个公司工作时，与同事的交流和学习。不过发布这本书的导火索，却在于一次在CSDN上读到一篇关于最新信息的报表问题的贴子。贴子中的问题可以用子查询和联接两种方式完成。由于条件所限，我不能详细解答，由此发贴的朋友不能理解我的本意，让我心生遗憾。所以决定将写书的想法付诸行动，并将这本书贴在CSDN上，与大家一起交流，共同进步。今天正好又见到类似于当日的问题，心生感触，决定在这里把它详细讨论一下。&nbsp;<BR>在实际工作中，我们有时会需要建立数据表来存储变动的数据，并由这些数据统计出我们所需的信息。其中有一类问题的特点在于最终结果的过滤条件来自分组统计后的数据。这类应用常见于网站数据库、财会系统、实时系统、数据仓库与数据挖掘等。事实上，这种命题本身已经包括了数据挖掘。现在，我们看下面的例子
<P></P>
<P>例4-4-1：最新报价</P>
<P>网友kikilyq问：</P>
<P>我有一个table:COMPUTER_PRICE，格式如下：</P>
<P>goods&nbsp;price&nbsp;dates</P>
<P>--------------------------------</P>
<P>HP电脑&nbsp;20000&nbsp;5.21</P>
<P>HP电脑&nbsp;20050&nbsp;5.23</P>
<P>NEC电脑&nbsp;31200&nbsp;5.3</P>
<P>NEC电脑&nbsp;32000&nbsp;5.5</P>
<P></P>
<P></P>
<P>查询结果要求：要查出每种电脑的最新价格；</P>
<P>上面表的结果为：</P>
<P>goods&nbsp;price&nbsp;dates</P>
<P>---------------------------------</P>
<P>HP电脑&nbsp;20050&nbsp;5.23</P>
<P>NEC电脑&nbsp;32000&nbsp;5.5</P>
<P>帮帮忙，搞定这个问题？</P>
<P></P>
<P></P>
<P>根据问题，我们先建立数据表，经分析，表中数据应由货物名和日期标示，所以设这两个字段为主关键字：</P>
<P>SQL&nbsp;Server版脚本如下</P>
<P>CREATE&nbsp;TABLE&nbsp;[dbo].[GOODS]&nbsp;(</P>
<P>[GOODS]&nbsp;[char]&nbsp;(10)&nbsp;COLLATE&nbsp;Chinese_PRC_CI_AS&nbsp;NOT&nbsp;NULL&nbsp;,</P>
<P>[PRICE]&nbsp;[money]&nbsp;NOT&nbsp;NULL&nbsp;,</P>
<P>[DATE_TIME]&nbsp;[datetime]&nbsp;NOT&nbsp;NULL&nbsp;,</P>
<P>PRIMARY&nbsp;KEY&nbsp;(GOODS,&nbsp;DATE_TIME)</P>
<P>)&nbsp;ON&nbsp;[PRIMARY]</P>
<P>InterBase版脚本如下</P>
<P>CREATE&nbsp;TABLE&nbsp;GOODS&nbsp;</P>
<P>(</P>
<P>GOODS&nbsp;CHAR(10)&nbsp;NOT&nbsp;NULL,</P>
<P>PRICE&nbsp;NUMERIC(15,&nbsp;4)&nbsp;NOT&nbsp;NULL,</P>
<P>DATE_TIME&nbsp;TIMESTAMP&nbsp;NOT&nbsp;NULL,</P>
<P>PRIMARY&nbsp;KEY&nbsp;(GOODS,&nbsp;DATE_TIME)</P>
<P>)</P>
<P>建立表后，请读者自行将数据插入。</P>
<P>这个问题中，最终报表中的电脑的价格取决于其后一次报价，也就是报价日期最新的那一行数据。典型地属于前面提到的类型。直觉来讲，我先试着选出每种电脑的最新报价日期，这个比较简单：</P>
<P>SELECT&nbsp;GOODS,&nbsp;MAX(DATE_TIME)</P>
<P>FROM&nbsp;GOODS</P>
<P>GROUP&nbsp;BY&nbsp;GOODS</P>
<P>返回结果</P>
<P>GOODS&nbsp;</P>
<P>----------&nbsp;------------------------------------------------------&nbsp;</P>
<P>HP&nbsp;2002-05-23&nbsp;00:00:00.000</P>
<P>NEC&nbsp;2002-05-05&nbsp;00:00:00.000</P>
<P>显然，只要把各品牌电脑在以上日期的报价显示出来，就是我们所要的结果了。那么直接这么写如何？</P>
<P>SELECT&nbsp;GOODS,&nbsp;PRICE,&nbsp;MAX(DATE_TIME)</P>
<P>FROM&nbsp;GOODS</P>
<P>GROUP&nbsp;BY&nbsp;GOODS</P>
<P>我想这个语句就不用试了，稍有经验的程序员会发现，PRICE列不在统计函数中，也不在GROUP&nbsp;BY&nbsp;之列，数据库系统无法执行这样的语句。这样的列一定要从另一个数据集中取出，所以我首先想到的是自联接。不过相信大多数朋友会先想到子查询。现在我们先看看子查询如何做，毕竟这样比较直观。最偷懒的办法是直接把PRICE表达为一个插入的标量子查询：</P>
<P>SELECT&nbsp;L.GOODS,</P>
<P>(SELECT&nbsp;R.PRICE&nbsp;FROM&nbsp;GOODS&nbsp;R&nbsp;WHERE&nbsp;R.GOODS&nbsp;=&nbsp;L.GOODS&nbsp;AND&nbsp;R.DATE_TIME&nbsp;=&nbsp;MAX(L.DATE_TIME))&nbsp;AS&nbsp;PRICE,</P>
<P>MAX(L.DATE_TIME)&nbsp;AS&nbsp;CURRENT_DATE_TIME</P>
<P>FROM&nbsp;GOODS&nbsp;L</P>
<P>GROUP&nbsp;BY&nbsp;L.GOODS</P>
<P>不过很遗憾，这个语句只能在SQL&nbsp;Server中执行，InterBase的提示是invalid&nbsp;column&nbsp;reference（无效的列引用）。不过换一个思路就可以写一个通用版。现在，我们对系统说，我要从表中取出部分行，每个品牌的电脑一行，其日期是这个牌子的最新报价日期：</P>
<P>SELECT&nbsp;L.GOODS,&nbsp;L.PRICE,&nbsp;L.DATE_TIME</P>
<P>FROM&nbsp;GOODS&nbsp;L</P>
<P>WHERE&nbsp;L.DATE_TIME&nbsp;=&nbsp;</P>
<P>(SELECT&nbsp;</P>
<P>MAX(R.DATE_TIME)&nbsp;</P>
<P>FROM&nbsp;GOODS&nbsp;R&nbsp;</P>
<P>WHERE&nbsp;R.GOODS&nbsp;=&nbsp;L.GOODS</P>
<P>GROUP&nbsp;BY&nbsp;R.GOODS)</P>
<P>这个</P>
<P>我想应该还可以写出几个不同的子查询变种，不过大同小异，就不一一尝试了。这个版本看来有些不可靠，因为主查询的WHERE条件中只有DATE_TIME，似乎不能准确地区分出每一行数据。不过放心，这里有一个“诡异”的相互引用，主查询的记录要满足日期等于子查询的返回值，而子查询的货物名（GOODS列）依赖于主查询的货物名（GOODS列）。这样，子查询会针对当前的品牌返回其正确日期，这是相关子查询的绝技，也是造成它在很多场合效率较差的原因。我对子查询的兴趣到此为止了，前面的文章中我说过，联接查询是一种很好的技术，那么这个查询有没有可能用联接来实现呢？前面对子查询的分析在这里会有助于我们的思考。现在我们如果有两个数据集，一个有最大日期，一个有价格，把它们一联接，不就可以了吗？这两个结果集就在上面的子查询中，现在的问题是我们如何把它们联接起来，显然，有一个联接条件是R.GOODS&nbsp;=&nbsp;L.GOODS&nbsp;，这同时也确定了最终结果集的唯一标识之一――GOODS列，而日期列的过滤条件照搬L.DATE_TIME&nbsp;=&nbsp;MAX(R.DATE_TIME)&nbsp;，加上GROUP&nbsp;BY结果集中的列，于是就有了：</P>
<P>SELECT&nbsp;L.GOODS,&nbsp;L.PRICE,&nbsp;L.DATE_TIME</P>
<P>FROM&nbsp;GOODS&nbsp;L</P>
<P>JOIN&nbsp;GOODS&nbsp;R</P>
<P>ON&nbsp;L.GOODS&nbsp;=&nbsp;R.GOODS</P>
<P>GROUP&nbsp;BY&nbsp;L.PRICE,&nbsp;L.GOODS,&nbsp;L.DATE_TIME</P>
<P>HAVING&nbsp;L.DATE_TIME&nbsp;=&nbsp;MAX(R.DATE_TIME)</P>
<P>有些朋友可能不明白这个GROUP&nbsp;BY&nbsp;为何而来，简单说一下。我们做了一个GOODS表的自联接（两个数据集分别是L和R）后，会生成一个迪卡尔积。有些人称之为数据爆炸。不过把矿石炸开之后，倒方便我们在其中找金子了。用JOIN条件一联接，L数据集中的每一种品牌在R数据集中都对应上了自己的所有报价日期。现在我们要对R数据集分组，选出每一品牌的最新报价日期，以其过滤L数据集就应该用</P>
<P>GROUP&nbsp;BY&nbsp;R.DATE_TIME</P>
<P>HAVING&nbsp;L.DATE_TIME&nbsp;=&nbsp;MAX(R.DATE_TIME)</P>
<P>由于我们要取出L数据集中的三列，所以要把它们也列在GROUP&nbsp;BY&nbsp;中，由于已经有了L.GOODS&nbsp;=&nbsp;R.GOODS&nbsp;这个联接条件，R.GOODS&nbsp;倒是可以不写在GROUP&nbsp;BY&nbsp;中了。由于我在前面的文章中提到过的种种理由，我个人比较喜欢用联接。当然从效率方面讲，当表中每个分组的数据很多时，联接查询的效率会因巨大的迪卡尔积而被抵消，这时应用子查询（如果这是一个记录生产线即时工作情况的表，统计其最新的生产情况，通常就是这样）；而表中每个分组的数据很少，但数据组很多（如大型网上书店，用户可能是一个天文数字，相对来说每个用户买的书就不多了）时，子查询仍要为主查询的每一行反复遍历整个表，效率就太低了，而联接只要处理事先生成的迪卡尔积，以空间上的代价换来了时间上的优势，这时应当用联接查询。</P>
<P>以上各种方案的返回结果集都是：</P>
<P>GOODS&nbsp;PRICE&nbsp;DATE_TIME&nbsp;</P>
<P>----------&nbsp;---------------------&nbsp;------------------------------------------------------&nbsp;</P>
<P>HP&nbsp;20050.0000&nbsp;2002-05-23&nbsp;00:00:00.000</P>
<P>NEC&nbsp;31000.0000&nbsp;2002-05-5&nbsp;00:00:00.000</P>
<P>除特别指明，以上脚本可在MS&nbsp;SQL&nbsp;Server7.0以上版本和InterBase6.0.1&nbsp;以上版本通用。掌握以设计以上脚本的方法，可以广泛用于各种以统计数据为查询条件的SQL编程。由此开始，我们还可以就两个有趣的方面展开讨论：联接查询和数据分组。</P>
<P>附：本来这个联接查询脚本还应当贴在&nbsp;kikilyq&nbsp;的问题后面，不过由于我愚蠢地贴了两个不该贴的贴子（一个有错，一个贴重了），CSDN的网页不允许我再往&nbsp;kikilyq&nbsp;的贴子后跟贴了。请kikilyq来这里读吧。抱歉。</P>
<P>关于《SQL&nbsp;Story》：这本书意在提出一些常见的SQL编程问题的解决方案，总结出一些关系型数据库设计和SQL语言编程方面的模式，通过实际问题，帮助读者提高数据库编程的能力，本书还会涉猎关系代数的理论领域。我计划在CSDN上收集一些典型的SQL&nbsp;编程问题，做为本书的重要内容。作者保证不剽窃任何人的劳动成果，所有解答及分析绝不假手于人。如有高手指点迷津，我一定会在文中明确指出并提出感谢。欢迎各位网友提供素材，在此先表示感激。另外我希望能有一位Oracle高手与我合作，完成这本书的Oracle部分。与我分享成功的喜悦和劳动的艰辛。</P>
<P>以下是我初步拟定的《SQL&nbsp;Story》&nbsp;提纲，也就是说，现在各篇文章的例题届时会分门别类出现在这本书的合适位置，可能现在的序号编排会有变动。</P></FONT>