<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>SELECT&nbsp;TOP&nbsp;N问题(2)(fang99)</B><BR>Hi,everyone:
<P></P>
<P>今天继续讨论SELECT&nbsp;TOP&nbsp;N问题.&nbsp;<BR>1.&nbsp;DB2的M&nbsp;2<BR>在前一篇讨论中提到,由于DB2的SUBQUERY不支持ORDER&nbsp;BY子句,因此无法构造M2.&nbsp;实际上,DB2提供了一组新的函数,称为&nbsp;OLAP&nbsp;FUNCTIONS,&nbsp;可以很好的支持TOP&nbsp;N问题.<BR>M2:<BR>SELECT&nbsp;*&nbsp;FROM&nbsp;<BR>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;SELECT&nbsp;MYKEY,RANK()&nbsp;OVER&nbsp;(ORDER&nbsp;BY&nbsp;ORD_COL&nbsp;DESC)&nbsp;AS&nbsp;MYRANK<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;MYTABLE&nbsp;)&nbsp;AS&nbsp;RANKED_TABLE<BR>WHERE&nbsp;MYRANK&lt;=N</P>
<P>利用OLAP函数,除了上一篇中所提方法,DB2的M1又可以表示为:<BR>SELECT&nbsp;*&nbsp;FROM&nbsp;<BR>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;SELECT&nbsp;MYKEY,ROW_NUMBER()&nbsp;OVER&nbsp;(ORDER&nbsp;BY&nbsp;ORD_COL&nbsp;DESC)&nbsp;AS&nbsp;MYRANK<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;MYTABLE&nbsp;)&nbsp;AS&nbsp;RANKED_TABLE<BR>WHERE&nbsp;MYRANK&lt;=N</P>
<P>2.&nbsp;除了M1,&nbsp;M2两种TOP&nbsp;N外,还有一种被DB2称为&nbsp;DENSE_RANK,&nbsp;(M3).&nbsp;通过下例分别说明.<BR>M1:&nbsp;TOP&nbsp;3&nbsp;--&nbsp;1(4,101),&nbsp;2(5,101),&nbsp;3(1,&nbsp;100)&nbsp;或者1(4,101),&nbsp;2(5,101),&nbsp;3(2,&nbsp;100)<BR>M2:&nbsp;TOP&nbsp;3&nbsp;--&nbsp;1(4,101),&nbsp;1(5,101),&nbsp;3(1,&nbsp;100),&nbsp;3(2,&nbsp;100)<BR>M3:&nbsp;TOP&nbsp;3&nbsp;--&nbsp;1(4,101),&nbsp;1(5,101),&nbsp;2(1,&nbsp;100),&nbsp;2(2,&nbsp;100),&nbsp;3(3,99)<BR>在DB2中,&nbsp;M3如此实现:<BR>SELECT&nbsp;*&nbsp;FROM&nbsp;<BR>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;SELECT&nbsp;MYKEY,DENSE_RANK()&nbsp;OVER&nbsp;(ORDER&nbsp;BY&nbsp;ORD_COL&nbsp;DESC)&nbsp;AS&nbsp;MYRANK<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;MYTABLE&nbsp;)&nbsp;AS&nbsp;RANKED_TABLE<BR>WHERE&nbsp;MYRANK&lt;=N</P>
<P>3.&nbsp;为避免DBMSs的方言问题,&nbsp;M2,M3可以有如下标准(SQL&nbsp;92)表示:<BR>M2:<BR>SELECT&nbsp;*&nbsp;FROM&nbsp;MYTABLE&nbsp;M1&nbsp;WHERE&nbsp;N&gt;<BR>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;SELECT&nbsp;COUNT(*)&nbsp;FROM&nbsp;MYTABLE&nbsp;M2&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;M2.ORD_COL&gt;M1.ORD_COL);<BR>注意:&nbsp;两个比较符都是&nbsp;&gt;&nbsp;<BR>M3:<BR>SELECT&nbsp;*&nbsp;FROM&nbsp;MYTABLE&nbsp;M1&nbsp;WHERE&nbsp;N&gt;<BR>&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;&nbsp;SELECT&nbsp;COUNT(DISTINCT&nbsp;M2.ORD_COL)&nbsp;FROM&nbsp;MYTABLE&nbsp;M2&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;M2.ORD_COL&gt;M1.ORD_COL);<BR>注意:&nbsp;与M2的不同在于DISTINCT的使用&nbsp;<BR>至于M1,&nbsp;我目前还没有想到合适的标准写法,请补充.</P>
<P>4.&nbsp;关于MYSQL<BR>相对于各主流RDBMS来说,MYSQL要简单,幼稚地多.&nbsp;在运行MYSQL时发现居然不支持SUBQUERY.&nbsp;因此MYSQL中的TOP&nbsp;N问题要复杂一些.<BR>SELECT&nbsp;*&nbsp;FROM&nbsp;MYTABLE,&nbsp;MYTABLE&nbsp;M2&nbsp;<BR>WHERE&nbsp;M2.ORD_COL&gt;=M1.ORD_COL<BR>GROUP&nbsp;BY&nbsp;M1.MYKEY<BR>HAVING&nbsp;COUNT(M2.ORD_COL)&nbsp;&lt;=N<BR>但是,这个语句是有问题的.&nbsp;一个极端的例子:&nbsp;当所有的ORD_COL的数值都一样时.&nbsp;如果哪位想到了如何解决这个问题,请补充.</P>
<P>----------------------------------------------------------------------------------<BR>各语句已经测试过,&nbsp;EXAMPLE:<BR>create&nbsp;table&nbsp;mytable(mykey&nbsp;int,&nbsp;ord_col&nbsp;int);<BR>insert&nbsp;into&nbsp;mytable&nbsp;values(1,&nbsp;100);<BR>insert&nbsp;into&nbsp;mytable&nbsp;values(2,&nbsp;100);<BR>insert&nbsp;into&nbsp;mytable&nbsp;values(3,&nbsp;99);<BR>insert&nbsp;into&nbsp;mytable&nbsp;values(4,&nbsp;101);<BR>insert&nbsp;into&nbsp;mytable&nbsp;values(5,&nbsp;101);</P>
<P>fang&nbsp;&nbsp;6/26/2000<BR></P></FONT>