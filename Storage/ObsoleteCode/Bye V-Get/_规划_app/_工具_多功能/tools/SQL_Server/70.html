<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>Advice&nbsp;on&nbsp;using&nbsp;COUNT(&nbsp;)</B><BR>In&nbsp;the&nbsp;SQL&nbsp;Server&nbsp;community,&nbsp;one&nbsp;thing&nbsp;that&nbsp;I&nbsp;sometimes&nbsp;encounter&nbsp;is&nbsp;the&nbsp;question&nbsp;on&nbsp;whether&nbsp;you&nbsp;should&nbsp;use&nbsp;COUNT(*)&nbsp;or&nbsp;COUNT(columnname),&nbsp;where&nbsp;columnname&nbsp;is&nbsp;a&nbsp;column&nbsp;in&nbsp;the&nbsp;table&nbsp;that&nbsp;you&nbsp;want&nbsp;to&nbsp;count&nbsp;the&nbsp;rows&nbsp;for.&nbsp;Often&nbsp;the&nbsp;advice&nbsp;given&nbsp;to&nbsp;people&nbsp;in&nbsp;forums&nbsp;and&nbsp;mailing&nbsp;lists&nbsp;is&nbsp;that&nbsp;COUNT(columnname)&nbsp;will&nbsp;perform&nbsp;better&nbsp;than&nbsp;COUNT(*).&nbsp;This&nbsp;is&nbsp;not&nbsp;always&nbsp;the&nbsp;correct&nbsp;advice&nbsp;though,&nbsp;in&nbsp;many&nbsp;cases&nbsp;it&nbsp;is&nbsp;even&nbsp;entirely&nbsp;wrong.&nbsp;Although&nbsp;there&nbsp;are&nbsp;situations&nbsp;where&nbsp;you&nbsp;can&nbsp;(or&nbsp;even&nbsp;should)&nbsp;use&nbsp;COUNT(columnname),&nbsp;you&nbsp;definitely&nbsp;shouldn't&nbsp;always&nbsp;use&nbsp;it.&nbsp;This&nbsp;incorrect&nbsp;piece&nbsp;of&nbsp;advice&nbsp;is&nbsp;probably&nbsp;based&nbsp;on&nbsp;a&nbsp;lack&nbsp;of&nbsp;understanding&nbsp;of&nbsp;how&nbsp;SQL&nbsp;Server&nbsp;handles&nbsp;data&nbsp;internally.&nbsp; 

<P></P>
<P>Description&nbsp;of&nbsp;COUNT(&nbsp;)<BR>The&nbsp;first&nbsp;thing&nbsp;that&nbsp;you&nbsp;need&nbsp;to&nbsp;know&nbsp;is&nbsp;that&nbsp;there&nbsp;is&nbsp;a&nbsp;difference&nbsp;between&nbsp;the&nbsp;alternative&nbsp;ways&nbsp;of&nbsp;using&nbsp;COUNT(&nbsp;),&nbsp;and&nbsp;what&nbsp;this&nbsp;difference&nbsp;is.&nbsp;The&nbsp;complete&nbsp;syntax&nbsp;for&nbsp;COUNT(&nbsp;)&nbsp;is&nbsp;this:&nbsp;</P>
<P>&nbsp;&nbsp;COUNT&nbsp;(&nbsp;{&nbsp;[&nbsp;ALL&nbsp;|&nbsp;DISTINCT&nbsp;]&nbsp;expression&nbsp;]&nbsp;|&nbsp;*&nbsp;}&nbsp;)&nbsp;</P>
<P>The&nbsp;word&nbsp;expression&nbsp;means&nbsp;any&nbsp;expression&nbsp;except&nbsp;for&nbsp;uniqueidentifier,&nbsp;text,&nbsp;ntext&nbsp;or&nbsp;image&nbsp;data,&nbsp;and&nbsp;it&nbsp;may&nbsp;not&nbsp;use&nbsp;aggregated&nbsp;functions&nbsp;or&nbsp;subqueries.&nbsp;Most&nbsp;often&nbsp;though,&nbsp;expression&nbsp;is&nbsp;just&nbsp;a&nbsp;column&nbsp;in&nbsp;the&nbsp;table.&nbsp;ALL&nbsp;is&nbsp;the&nbsp;default,&nbsp;which&nbsp;means&nbsp;that&nbsp;writing&nbsp;COUNT(expression)&nbsp;is&nbsp;equal&nbsp;to&nbsp;writing&nbsp;COUNT(ALL&nbsp;expression).&nbsp;</P>
<P>COUNT(*)&nbsp;returns&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;rows&nbsp;in&nbsp;the&nbsp;table,&nbsp;while&nbsp;COUNT(expression)&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;where&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;expression&nbsp;is&nbsp;not&nbsp;NULL.&nbsp;Naturally,&nbsp;COUNT(DISTINCT&nbsp;expression)&nbsp;means&nbsp;that&nbsp;duplicates&nbsp;are&nbsp;only&nbsp;counted&nbsp;once.&nbsp;This&nbsp;means&nbsp;that&nbsp;COUNT(&nbsp;)&nbsp;can&nbsp;return&nbsp;different&nbsp;results&nbsp;depending&nbsp;on&nbsp;how&nbsp;you&nbsp;write&nbsp;it.&nbsp;</P>
<P>Myths&nbsp;and&nbsp;facts<BR>As&nbsp;I&nbsp;said&nbsp;earlier,&nbsp;many&nbsp;people&nbsp;believe&nbsp;COUNT(columnname)&nbsp;is&nbsp;faster&nbsp;than&nbsp;using&nbsp;COUNT(*),&nbsp;because&nbsp;COUNT(*)&nbsp;would&nbsp;have&nbsp;to&nbsp;read&nbsp;all&nbsp;columns&nbsp;of&nbsp;each&nbsp;row&nbsp;(just&nbsp;like&nbsp;executing&nbsp;a&nbsp;SELECT&nbsp;*&nbsp;FROM&nbsp;MYTABLE&nbsp;statement),&nbsp;while&nbsp;COUNT(columnname)&nbsp;only&nbsp;need&nbsp;to&nbsp;read&nbsp;the&nbsp;specified&nbsp;column.&nbsp;This&nbsp;is&nbsp;not&nbsp;true&nbsp;though,&nbsp;for&nbsp;several&nbsp;reasons.&nbsp;</P>
<P>First&nbsp;of&nbsp;all,&nbsp;SQL&nbsp;Server&nbsp;can't&nbsp;read&nbsp;just&nbsp;the&nbsp;contents&nbsp;of&nbsp;a&nbsp;single&nbsp;column&nbsp;without&nbsp;reading&nbsp;the&nbsp;entire&nbsp;row.&nbsp;SQL&nbsp;Server&nbsp;stores&nbsp;the&nbsp;rows&nbsp;with&nbsp;the&nbsp;data&nbsp;on&nbsp;8&nbsp;KB&nbsp;data&nbsp;pages&nbsp;on&nbsp;disk.&nbsp;These&nbsp;pages&nbsp;contain&nbsp;one&nbsp;or&nbsp;more&nbsp;rows&nbsp;(depending&nbsp;on&nbsp;the&nbsp;size&nbsp;of&nbsp;each&nbsp;individual&nbsp;row,&nbsp;which&nbsp;may&nbsp;be&nbsp;up&nbsp;to&nbsp;8060&nbsp;bytes,&nbsp;with&nbsp;some&nbsp;exceptions),&nbsp;and&nbsp;these&nbsp;pages&nbsp;are&nbsp;placed&nbsp;in&nbsp;the&nbsp;internal&nbsp;memory&nbsp;(RAM)&nbsp;when&nbsp;SQL&nbsp;Server&nbsp;needs&nbsp;to&nbsp;access&nbsp;them&nbsp;for&nbsp;any&nbsp;reason.&nbsp;To&nbsp;check&nbsp;the&nbsp;value&nbsp;of&nbsp;a&nbsp;single&nbsp;column&nbsp;(or&nbsp;several&nbsp;of&nbsp;course),&nbsp;an&nbsp;entire&nbsp;page&nbsp;has&nbsp;to&nbsp;be&nbsp;read&nbsp;from&nbsp;disk&nbsp;and&nbsp;placed&nbsp;in&nbsp;memory.&nbsp;The&nbsp;pages&nbsp;may&nbsp;of&nbsp;course&nbsp;already&nbsp;be&nbsp;cached&nbsp;in&nbsp;memory,&nbsp;in&nbsp;which&nbsp;case&nbsp;the&nbsp;read&nbsp;will&nbsp;be&nbsp;much&nbsp;faster,&nbsp;but&nbsp;SQL&nbsp;still&nbsp;needs&nbsp;to&nbsp;read&nbsp;an&nbsp;entire&nbsp;page&nbsp;from&nbsp;memory&nbsp;just&nbsp;to&nbsp;check&nbsp;a&nbsp;single&nbsp;column&nbsp;of&nbsp;a&nbsp;row.&nbsp;</P>
<P>Now,&nbsp;to&nbsp;avoid&nbsp;having&nbsp;to&nbsp;read&nbsp;these&nbsp;entire&nbsp;data&nbsp;pages&nbsp;when&nbsp;all&nbsp;you&nbsp;are&nbsp;really&nbsp;interested&nbsp;in&nbsp;is&nbsp;how&nbsp;many&nbsp;rows&nbsp;there&nbsp;are&nbsp;in&nbsp;a&nbsp;table,&nbsp;SQL&nbsp;Server&nbsp;will&nbsp;use&nbsp;an&nbsp;index&nbsp;instead,&nbsp;if&nbsp;one&nbsp;exists.&nbsp;Indexes&nbsp;are&nbsp;stored&nbsp;in&nbsp;the&nbsp;same&nbsp;way&nbsp;as&nbsp;data,&nbsp;on&nbsp;8&nbsp;KB&nbsp;index&nbsp;pages.&nbsp;Since&nbsp;an&nbsp;index&nbsp;is&nbsp;probably&nbsp;not&nbsp;as&nbsp;wide&nbsp;as&nbsp;a&nbsp;data&nbsp;row&nbsp;(the&nbsp;index&nbsp;only&nbsp;consists&nbsp;of&nbsp;some&nbsp;or&nbsp;even&nbsp;one&nbsp;of&nbsp;the&nbsp;columns&nbsp;in&nbsp;the&nbsp;row),&nbsp;an&nbsp;index&nbsp;page&nbsp;can&nbsp;usually&nbsp;fit&nbsp;a&nbsp;lot&nbsp;more&nbsp;rows&nbsp;per&nbsp;page&nbsp;than&nbsp;the&nbsp;data&nbsp;pages&nbsp;can.&nbsp;This&nbsp;means&nbsp;that&nbsp;SQL&nbsp;Server&nbsp;doesn't&nbsp;have&nbsp;to&nbsp;read&nbsp;as&nbsp;many&nbsp;pages&nbsp;to&nbsp;check&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;in&nbsp;the&nbsp;index&nbsp;as&nbsp;it&nbsp;does&nbsp;with&nbsp;the&nbsp;data&nbsp;pages,&nbsp;which&nbsp;is&nbsp;of&nbsp;course&nbsp;a&nbsp;good&nbsp;thing.&nbsp;</P>
<P>This&nbsp;does&nbsp;not&nbsp;only&nbsp;apply&nbsp;to&nbsp;COUNT(columnname_with_an_index_defined_on_it),&nbsp;COUNT(*)&nbsp;will&nbsp;of&nbsp;course&nbsp;also&nbsp;use&nbsp;the&nbsp;index&nbsp;to&nbsp;count&nbsp;the&nbsp;rows.&nbsp;In&nbsp;some&nbsp;cases&nbsp;there&nbsp;may&nbsp;not&nbsp;be&nbsp;an&nbsp;index&nbsp;that&nbsp;covers&nbsp;the&nbsp;specified&nbsp;column&nbsp;in&nbsp;a&nbsp;COUNT(columnname)&nbsp;query,&nbsp;but&nbsp;there&nbsp;is&nbsp;an&nbsp;index&nbsp;defined&nbsp;on&nbsp;another&nbsp;column&nbsp;of&nbsp;the&nbsp;table.&nbsp;In&nbsp;this&nbsp;case&nbsp;COUNT(*)&nbsp;would&nbsp;use&nbsp;this&nbsp;other&nbsp;index&nbsp;to&nbsp;count&nbsp;the&nbsp;number&nbsp;of&nbsp;rows,&nbsp;but&nbsp;COUNT(columnname_without_an_index)&nbsp;would&nbsp;have&nbsp;to&nbsp;read&nbsp;the&nbsp;data&nbsp;pages&nbsp;to&nbsp;check&nbsp;the&nbsp;column&nbsp;for&nbsp;NULL&nbsp;values&nbsp;and&nbsp;count&nbsp;the&nbsp;rows.&nbsp;</P>
<P>To&nbsp;try&nbsp;this&nbsp;for&nbsp;yourself,&nbsp;run&nbsp;the&nbsp;following&nbsp;script&nbsp;in&nbsp;SQL&nbsp;Query&nbsp;Analyzer&nbsp;(if&nbsp;it&nbsp;is&nbsp;not&nbsp;already&nbsp;set&nbsp;to&nbsp;show&nbsp;the&nbsp;results&nbsp;in&nbsp;text&nbsp;mode,&nbsp;use&nbsp;Ctrl-T&nbsp;to&nbsp;set&nbsp;it&nbsp;that&nbsp;way):&nbsp;</P>
<P>USE&nbsp;Northwind<BR>GO<BR>&nbsp;<BR>SET&nbsp;STATISTICS&nbsp;IO&nbsp;ON<BR>&nbsp;<BR>SELECT&nbsp;COUNT(*)&nbsp;FROM&nbsp;Orders<BR>SELECT&nbsp;COUNT(CustomerId)&nbsp;FROM&nbsp;Orders<BR>SELECT&nbsp;*&nbsp;FROM&nbsp;Orders<BR>&nbsp;<BR>SET&nbsp;STATISTICS&nbsp;IO&nbsp;OFF&nbsp;</P>
<P>The&nbsp;statement&nbsp;SET&nbsp;STATISTICS&nbsp;IO&nbsp;ON&nbsp;configures&nbsp;SQL&nbsp;Server&nbsp;to&nbsp;output&nbsp;statistics&nbsp;showing&nbsp;the&nbsp;amount&nbsp;of&nbsp;I/O&nbsp;that&nbsp;was&nbsp;required&nbsp;to&nbsp;execute&nbsp;the&nbsp;query,&nbsp;and&nbsp;you&nbsp;can&nbsp;use&nbsp;it&nbsp;to&nbsp;compare&nbsp;the&nbsp;amount&nbsp;of&nbsp;resources&nbsp;used&nbsp;by&nbsp;different&nbsp;queries&nbsp;to&nbsp;decide&nbsp;which&nbsp;one&nbsp;to&nbsp;use.&nbsp;You&nbsp;can&nbsp;find&nbsp;this&nbsp;output&nbsp;directly&nbsp;after&nbsp;the&nbsp;results&nbsp;of&nbsp;the&nbsp;statement&nbsp;executed.&nbsp;The&nbsp;statistics&nbsp;we&nbsp;are&nbsp;interested&nbsp;in&nbsp;here&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;logical&nbsp;and/or&nbsp;physical&nbsp;page&nbsp;reads.&nbsp;Logical&nbsp;page&nbsp;reads&nbsp;is&nbsp;the&nbsp;amount&nbsp;of&nbsp;pages&nbsp;(data&nbsp;and/or&nbsp;index&nbsp;pages)&nbsp;that&nbsp;was&nbsp;read&nbsp;from&nbsp;memory,&nbsp;and&nbsp;physical&nbsp;page&nbsp;reads&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;pages&nbsp;read&nbsp;from&nbsp;disk.&nbsp;On&nbsp;my&nbsp;computer&nbsp;the&nbsp;result&nbsp;of&nbsp;COUNT(&nbsp;)&nbsp;shows&nbsp;830&nbsp;rows&nbsp;for&nbsp;both&nbsp;alternatives,&nbsp;which&nbsp;is&nbsp;probably&nbsp;also&nbsp;what&nbsp;you&nbsp;got&nbsp;if&nbsp;you&nbsp;haven't&nbsp;added&nbsp;or&nbsp;deleted&nbsp;any&nbsp;rows&nbsp;from&nbsp;the&nbsp;Orders&nbsp;table.&nbsp;Now&nbsp;note&nbsp;the&nbsp;number&nbsp;of&nbsp;logical&nbsp;page&nbsp;reads&nbsp;for&nbsp;these&nbsp;statements&nbsp;(run&nbsp;the&nbsp;script&nbsp;a&nbsp;couple&nbsp;of&nbsp;times&nbsp;if&nbsp;you're&nbsp;getting&nbsp;physical&nbsp;page&nbsp;reads&nbsp;to&nbsp;cache&nbsp;the&nbsp;data&nbsp;in&nbsp;memory).&nbsp;I&nbsp;have&nbsp;3&nbsp;logical&nbsp;page&nbsp;reads&nbsp;for&nbsp;the&nbsp;first&nbsp;alternative,&nbsp;and&nbsp;21&nbsp;logical&nbsp;page&nbsp;reads&nbsp;for&nbsp;the&nbsp;second&nbsp;one!&nbsp;Also&nbsp;note&nbsp;that&nbsp;the&nbsp;third&nbsp;statement&nbsp;that&nbsp;SELECTs&nbsp;all&nbsp;of&nbsp;the&nbsp;rows&nbsp;from&nbsp;the&nbsp;table&nbsp;also&nbsp;resulted&nbsp;in&nbsp;21&nbsp;logical&nbsp;page&nbsp;reads.&nbsp;This&nbsp;shows&nbsp;us&nbsp;that&nbsp;the&nbsp;second&nbsp;statement&nbsp;had&nbsp;to&nbsp;read&nbsp;all&nbsp;of&nbsp;the&nbsp;data&nbsp;pages&nbsp;just&nbsp;to&nbsp;count&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;in&nbsp;Orders&nbsp;because&nbsp;there&nbsp;is&nbsp;no&nbsp;index&nbsp;on&nbsp;the&nbsp;CustomerId&nbsp;column,&nbsp;but&nbsp;the&nbsp;first&nbsp;statement&nbsp;is&nbsp;able&nbsp;to&nbsp;use&nbsp;an&nbsp;index&nbsp;(on&nbsp;my&nbsp;computer&nbsp;the&nbsp;index&nbsp;ShippersOrders&nbsp;was&nbsp;used;&nbsp;I&nbsp;checked&nbsp;the&nbsp;execution&nbsp;plan&nbsp;for&nbsp;the&nbsp;query&nbsp;to&nbsp;find&nbsp;that&nbsp;out)&nbsp;to&nbsp;count&nbsp;the&nbsp;rows.&nbsp;</P>
<P>Which&nbsp;one&nbsp;to&nbsp;use?&nbsp;<BR>As&nbsp;I&nbsp;have&nbsp;shown,&nbsp;using&nbsp;COUNT(*)&nbsp;does&nbsp;certainly&nbsp;not&nbsp;mean&nbsp;poor&nbsp;performance.&nbsp;On&nbsp;the&nbsp;contrary,&nbsp;in&nbsp;some&nbsp;cases&nbsp;you&nbsp;may&nbsp;instead&nbsp;get&nbsp;poor&nbsp;performance&nbsp;from&nbsp;using&nbsp;COUNT(expression).&nbsp;Normally&nbsp;you&nbsp;probably&nbsp;won't&nbsp;encounter&nbsp;the&nbsp;problem&nbsp;in&nbsp;the&nbsp;example&nbsp;above,&nbsp;as&nbsp;you&nbsp;will&nbsp;probably&nbsp;have&nbsp;an&nbsp;index&nbsp;on&nbsp;the&nbsp;column&nbsp;you&nbsp;specified.&nbsp;What&nbsp;is&nbsp;worse&nbsp;though&nbsp;is&nbsp;that&nbsp;you&nbsp;may&nbsp;receive&nbsp;a&nbsp;different&nbsp;result&nbsp;from&nbsp;what&nbsp;you&nbsp;were&nbsp;expecting!&nbsp;Let's&nbsp;say&nbsp;that&nbsp;you&nbsp;have&nbsp;a&nbsp;legacy&nbsp;application&nbsp;that&nbsp;uses&nbsp;COUNT(columnname)&nbsp;to&nbsp;count&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;of&nbsp;a&nbsp;table,&nbsp;where&nbsp;columnname&nbsp;represents&nbsp;a&nbsp;column&nbsp;that&nbsp;does&nbsp;not&nbsp;allow&nbsp;NULL&nbsp;values.&nbsp;Now,&nbsp;sometime&nbsp;later,&nbsp;the&nbsp;definition&nbsp;for&nbsp;the&nbsp;column&nbsp;is&nbsp;changed&nbsp;to&nbsp;allow&nbsp;NULL&nbsp;values.&nbsp;As&nbsp;soon&nbsp;as&nbsp;someone&nbsp;enters&nbsp;a&nbsp;NULL&nbsp;value&nbsp;in&nbsp;the&nbsp;column,&nbsp;your&nbsp;application&nbsp;will&nbsp;no&nbsp;longer&nbsp;show&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;in&nbsp;the&nbsp;table&nbsp;but&nbsp;instead&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;with&nbsp;non-NULL&nbsp;values&nbsp;in&nbsp;the&nbsp;specified&nbsp;column!&nbsp;That&nbsp;may&nbsp;not&nbsp;be&nbsp;what&nbsp;the&nbsp;designers&nbsp;of&nbsp;the&nbsp;application&nbsp;intended&nbsp;and&nbsp;expected,&nbsp;and&nbsp;could&nbsp;possibly&nbsp;cause&nbsp;major&nbsp;problems.&nbsp;</P>
<P>But...&nbsp;<BR>So,&nbsp;normally&nbsp;there&nbsp;is&nbsp;no&nbsp;reason&nbsp;not&nbsp;to&nbsp;use&nbsp;COUNT(*).&nbsp;But&nbsp;as&nbsp;I&nbsp;mentioned&nbsp;in&nbsp;the&nbsp;beginning&nbsp;of&nbsp;the&nbsp;article&nbsp;there&nbsp;are&nbsp;situations&nbsp;where&nbsp;you&nbsp;want&nbsp;to&nbsp;(or&nbsp;rather&nbsp;should)&nbsp;use&nbsp;COUNT(expression).&nbsp;One&nbsp;obvious&nbsp;example&nbsp;is&nbsp;of&nbsp;course&nbsp;if&nbsp;you&nbsp;are&nbsp;really&nbsp;only&nbsp;interested&nbsp;in&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;where&nbsp;the&nbsp;column&nbsp;value&nbsp;is&nbsp;not&nbsp;NULL.&nbsp;A&nbsp;typical&nbsp;example&nbsp;of&nbsp;a&nbsp;situation&nbsp;like&nbsp;that&nbsp;is&nbsp;when&nbsp;you&nbsp;use&nbsp;COUNT(&nbsp;)&nbsp;together&nbsp;with&nbsp;another&nbsp;aggregated&nbsp;function.&nbsp;Let's&nbsp;say&nbsp;we&nbsp;have&nbsp;a&nbsp;table&nbsp;with&nbsp;some&nbsp;sort&nbsp;of&nbsp;measure&nbsp;data,&nbsp;with&nbsp;NULL&nbsp;values&nbsp;in&nbsp;some&nbsp;rows.&nbsp;Now&nbsp;we're&nbsp;looking&nbsp;for&nbsp;an&nbsp;average&nbsp;of&nbsp;these&nbsp;values.&nbsp;Normally,&nbsp;we&nbsp;would&nbsp;use&nbsp;AVG(&nbsp;)&nbsp;for&nbsp;this,&nbsp;but&nbsp;to&nbsp;see&nbsp;the&nbsp;point&nbsp;we'll&nbsp;say&nbsp;we're&nbsp;not&nbsp;allowed&nbsp;to&nbsp;use&nbsp;it.&nbsp;Compare&nbsp;these&nbsp;two&nbsp;statements&nbsp;and&nbsp;see&nbsp;if&nbsp;you&nbsp;spot&nbsp;the&nbsp;problem:&nbsp;</P>
<P>SELECT&nbsp;SUM(column)&nbsp;/&nbsp;COUNT(*)&nbsp;FROM&nbsp;table<BR>&nbsp;<BR>SELECT&nbsp;SUM(column)&nbsp;/&nbsp;COUNT(column)&nbsp;FROM&nbsp;table</P>
<P><BR>These&nbsp;statements&nbsp;will&nbsp;return&nbsp;different&nbsp;average&nbsp;results,&nbsp;since&nbsp;SUM(&nbsp;)&nbsp;ignores&nbsp;NULL&nbsp;values&nbsp;(they&nbsp;are&nbsp;not&nbsp;counted&nbsp;as&nbsp;0).&nbsp;If&nbsp;the&nbsp;sum&nbsp;is&nbsp;1500,&nbsp;and&nbsp;the&nbsp;number&nbsp;of&nbsp;rows&nbsp;is&nbsp;150,&nbsp;of&nbsp;which&nbsp;50&nbsp;have&nbsp;NULL&nbsp;in&nbsp;the&nbsp;specified&nbsp;column,&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;first&nbsp;query&nbsp;will&nbsp;be&nbsp;10&nbsp;(1500/150)&nbsp;and&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;second&nbsp;query&nbsp;will&nbsp;be&nbsp;15&nbsp;(1500/100).&nbsp;This&nbsp;is&nbsp;actually&nbsp;a&nbsp;problem&nbsp;that&nbsp;I&nbsp;encounter&nbsp;quite&nbsp;often&nbsp;in&nbsp;my&nbsp;work&nbsp;as&nbsp;a&nbsp;database&nbsp;consultant,&nbsp;and&nbsp;most&nbsp;often&nbsp;it&nbsp;exists&nbsp;due&nbsp;to&nbsp;the&nbsp;fact&nbsp;that&nbsp;the&nbsp;person&nbsp;who&nbsp;wrote&nbsp;the&nbsp;SQL&nbsp;statement&nbsp;where&nbsp;not&nbsp;aware&nbsp;of&nbsp;how&nbsp;NULL&nbsp;values&nbsp;are&nbsp;handled&nbsp;differently&nbsp;in&nbsp;different&nbsp;aggregated&nbsp;functions&nbsp;(SUM(&nbsp;)&nbsp;and&nbsp;COUNT(&nbsp;)&nbsp;in&nbsp;the&nbsp;example&nbsp;above).&nbsp;</P></FONT>