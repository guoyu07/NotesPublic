<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>存储过程重新编译的疑难解答(一)--MS(GHOST)</B><BR>INF：&nbsp;存储过程重新编译的疑难解答<BR>这篇文章中的信息适用于:&nbsp;<BR>Microsoft&nbsp;SQL&nbsp;Server&nbsp;7.0<BR>概要<BR>本文介绍应用程序在使用&nbsp;Microsoft&nbsp;SQL&nbsp;Server&nbsp;时可能遇到的一种特定类型的性能问题：&nbsp;?′￡?存储过程的运行时重新编译。&nbsp;如果您正在解决某个性能问题，但还不能确定这是否是问题的真正原因，请在继续本文之前参考&nbsp;Microsoft&nbsp;Knowledge&nbsp;Base&nbsp;中的下列文章：&nbsp;
<P></P>
<P><BR>Q224587&nbsp;INF：&nbsp;解决&nbsp;SQL&nbsp;Server&nbsp;中的应用程序性能问题&nbsp;<BR>本文假设通过参阅以上文章缩小了引起问题的范围，并且捕获了对特定事件和其中详细数据列的&nbsp;SQL&nbsp;Server&nbsp;事件探查器跟踪。&nbsp;<BR>更多信息<BR>在&nbsp;SQL&nbsp;Server&nbsp;7.0&nbsp;中创建存储过程时，过程的文本存储在&nbsp;syscomments&nbsp;系统表中。&nbsp;在用户执行过程时，如果过程还不在高速缓存中，SQL&nbsp;Server&nbsp;将从&nbsp;syscomments（在早期版的&nbsp;SQL&nbsp;Server&nbsp;中为&nbsp;sysprocedures）中加载过程，并编译查询计划。&nbsp;已编译的计划保存在高速缓存中，并在以后调用存储过程时再次使用，直到发生某个操作使计划无效并强制进行重新编译为止。&nbsp;下列操作可能会引起存储过程计划的重新编译。&nbsp;<BR>在&nbsp;CREATE&nbsp;PROCEDURE&nbsp;或&nbsp;EXECUTE&nbsp;语句中使用&nbsp;WITH&nbsp;RECOMPILE&nbsp;子句。&nbsp;<BR>对任何过程所引用对象的架构进行更改，包括添加或取消约束、默认值或规则。&nbsp;<BR>对过程所引用的表运行&nbsp;sp_recompile。&nbsp;<BR>恢复包含过程或过程引用的任意对象的数据库（如果执行的是跨数据库操作）。&nbsp;<BR>太多的服务器活动引起计划在高速缓存中超时。&nbsp;<BR>重新编译存储过程的所有这些原因在早期版本中确实存在，并导致在开始执行过程前重新编译过程。&nbsp;在&nbsp;SQL&nbsp;Server&nbsp;7.0&nbsp;中，引入了一个新功能，该功能使得可以在执行期间重新编译存储过程。&nbsp;这种新功能可保证优化器对过程内的每个特定语句总是有最可行的计划。&nbsp;下列事件可能会引起存储过程的运行时重新编译：&nbsp;<BR>存储过程引用的表中的大部分数据发生了更改。&nbsp;<BR>过程交错执行数据定义语言&nbsp;(DDL)&nbsp;和数据操作语言&nbsp;(DML)&nbsp;操作。&nbsp;<BR>过程在临时表上执行特定的操作。&nbsp;<BR>上述所有情况的原因将在本文下面给予进一步的详细讨论。&nbsp;</P>
<P>在某些情况下，重新编译存储过程的开销远远大于所带来好处，对于大型过程尤其如此。&nbsp;切记：启动重新编译时，整个批处理或过程均进行重新编译。&nbsp;这意味着性能的下降直接与过程或批处理的大小成比例。&nbsp;有关该主题的更多信息，请参阅&nbsp;SQL&nbsp;Server&nbsp;7.0&nbsp;Books&nbsp;Online&nbsp;中的“Transact-SQL&nbsp;Tips”主题。&nbsp;</P>
<P><BR>本文下面的内容将集中在如何识别引起运行时存储过程重新编译的原因，并讨论可以用来防止重新编译的方法。&nbsp;</P>
<P><BR>最优准则&nbsp;</P>
<P><BR>当作为非所有者执行某个过程时，最好完全限定存储过程名称。&nbsp;这样做会更明确且更易于当前用户重新使用现有执行计划。&nbsp;例如，如果一个非数据库所有者&nbsp;(dbo)&nbsp;用户执行了数据库所有者&nbsp;(dbo)&nbsp;所拥有的&nbsp;pubs&nbsp;数据库中的存储过程（在本例中为&nbsp;myProc），则应当使用下面的语句：&nbsp;<BR>exec&nbsp;pubs.dbo.myProc<BR>而不要使用下面的语句：&nbsp;<BR>exec&nbsp;myProc<BR>这种技术从编码和维护的角度，消除了不同所有者使用不同过程版本的混乱状况，同时也允许&nbsp;SQL&nbsp;Server&nbsp;更直接地访问特定过程的执行计划。&nbsp;<BR>识别和解决问题&nbsp;</P>
<P><BR>如果还没有这么做，要得到详细的信息，请参考&nbsp;Microsoft&nbsp;Knowledge&nbsp;Base&nbsp;中关于捕获“事件探查器”数据帮助分析系统性能的文章：&nbsp;<BR>Q224587&nbsp;INF：&nbsp;解决&nbsp;SQL&nbsp;Server&nbsp;中的应用程序性能问题&nbsp;<BR>查看“事件探查器”数据&nbsp;</P>
<P><BR>SQL&nbsp;Server&nbsp;事件探查器包括&nbsp;SP:Recompile&nbsp;事件，可以利用这个事件监控重新编译发生的次数。&nbsp;只要在执行期间发生存储过程重新编译，就会发生&nbsp;SP:Recompile&nbsp;事件。&nbsp;<BR>根据&nbsp;Event&nbsp;Class&nbsp;对“事件探查器”跟踪进行分组：</P>
<P><BR>在文件菜单上，单击属性。&nbsp;<BR>在&nbsp;Data&nbsp;Columns&nbsp;选项卡上，使用向上按钮移动&nbsp;Groups&nbsp;标题下的&nbsp;Event&nbsp;Class&nbsp;及&nbsp;Text（Event&nbsp;Class&nbsp;在先）。&nbsp;使用向下按钮删除组标题下的所有其它列。&nbsp;<BR>单击确定。&nbsp;<BR>检查&nbsp;SP:Recompile&nbsp;事件个数。&nbsp;</P>
<P>可以展开&nbsp;SP:Recompile&nbsp;组以查看每次发生重新编译时的详细信息。&nbsp;事件的&nbsp;Text&nbsp;列指出重新编译的存储过程名称。&nbsp;如果多个过程正在引发重新编译事件，则按发生的次数进行存储?￡&nbsp;如果有大量的&nbsp;SP:Recompile&nbsp;事件，而且此时&nbsp;CPU&nbsp;占用率很高，则集中解决重新编译次数最多的过程。&nbsp;请注意特定存储过程的一个实例的&nbsp;SP:Recompile&nbsp;事件的系统进程&nbsp;ID&nbsp;(SPID)&nbsp;和“启动时间”(Start&nbsp;Time)，并按照下面的步骤执行。如果没有看到任何&nbsp;SP:Recompile&nbsp;事件，但是仍然遇到性能问题，请参见&nbsp;Microsoft&nbsp;Knowledge&nbsp;Base&nbsp;中的下列文章：&nbsp;<BR>Q224587&nbsp;INF：&nbsp;解决&nbsp;SQL&nbsp;Server&nbsp;中的应用程序性能问题&nbsp;<BR>找出引发重新编译事件的语句</P>
<P><BR>在文件菜单上，单击属性。&nbsp;<BR>在&nbsp;Data&nbsp;Columns&nbsp;选项卡上，使用向下按钮删除&nbsp;Groups&nbsp;标题下的所有其它列。&nbsp;<BR>在&nbsp;Events&nbsp;选项卡上，删除除&nbsp;SP:Starting、SP:StmtStarting、SP:Recompile&nbsp;和&nbsp;SP:Completed&nbsp;之外的所有其它事件。&nbsp;如果不捕获&nbsp;SP:StmtStarting&nbsp;事件，可以替换为&nbsp;SP:StmtCompleted&nbsp;事件，但不能同时包含这两个事件，因为这样会将需要查询的信息量加倍。&nbsp;<BR>如果已经识别出要检查的存储过程重新编译的特定实例，则通过使用&nbsp;Filters&nbsp;选项卡，可以将查看的数据限定为事件发生时的特定&nbsp;SPID&nbsp;和时间范围。&nbsp;<BR>单击确定。&nbsp;</P>
<P>SP:Recompile&nbsp;事件将在发生存储过程语句引起重新编译的&nbsp;SP:StmtStarted&nbsp;事件之后立即发生。&nbsp;重新编译事件完成后，将会看到&nbsp;SP:StmtStarted&nbsp;事件重新出现，表明正在使用新生成的计划执行语句。&nbsp;</P>
<P>请考虑下列示例：&nbsp;<BR>use&nbsp;pubsgodrop&nbsp;procedure&nbsp;RecompProc&nbsp;gocreate&nbsp;procedure&nbsp;RecompProc&nbsp;ascreate&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int)select&nbsp;*&nbsp;from&nbsp;#tgoexec&nbsp;RecompProc<BR>如果在&nbsp;Query&nbsp;Analyzer&nbsp;中执行该代码并在“事件探查器”跟踪中查看上述事件，将看到下列序列：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;RecompProc&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;RecompProc&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;RecompProc&nbsp;&nbsp;</P>
<P><BR>您可以立即指出引起重新编译的语句是：&nbsp;</P>
<P>select&nbsp;*&nbsp;from&nbsp;#t<BR>因为它出现在&nbsp;SP:Recompile&nbsp;事件的前后。&nbsp;</P>
<P>如果您仅捕获&nbsp;SP:StmtCompleted&nbsp;事件，而没有捕获&nbsp;SP:StmtStarting&nbsp;事件，SP:Recompile&nbsp;事件将直接出现在引发该事件的语句之前，如下所示：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;RecompProc&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;RecompProc&nbsp;&nbsp;<BR>SP:StmtCompleted&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;RecompProc&nbsp;&nbsp;</P>
<P><BR>可以看到&nbsp;SP:Recompile&nbsp;事件在&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;语句的&nbsp;SP:StmtCompleted&nbsp;事件之前发生，从而引起了重新编译。&nbsp;这是有道理的，因为直到为重新编译生成了新查询计划之后，才能完成该语句。&nbsp;本文的其余示例均使用&nbsp;SP:StmtStarting&nbsp;事件。&nbsp;如果您仅捕获&nbsp;SP:StmtCompleted&nbsp;事件，切记查看&nbsp;SP:Recompile&nbsp;之后的语句，如上所述。&nbsp;</P>
<P>注意：如果多次执行这个特定存储过程，SQL&nbsp;Server&nbsp;将重用该过程的现有计划。&nbsp;您只在第一次执行过程时或在每次执行脚本时删除并重新创建过程时，才会看到重新编译事件。&nbsp;在本文“由于交错执行数据定义语句&nbsp;(DDL)&nbsp;和数据操作语句&nbsp;(DML)&nbsp;操作引起重新编译”部分讨论这一特定情况下引起的重新编译的原因；这只是一个简单的示例以演示如何找到引起重新编译的语句。&nbsp;<BR>由于行修改引起的重新编译&nbsp;</P>
<P><BR>自从生成原始查询计划以来，如果由存储过程所引用的表中的大多数数据已发生更改，SQL&nbsp;Server&nbsp;将重新编译存储过程以确保它有一个基于最新统计数据的计划。&nbsp;例如，请考虑下列存储过程￡o&nbsp;<BR>drop&nbsp;procedure&nbsp;RowModifications&nbsp;gocreate&nbsp;procedure&nbsp;RowModifications&nbsp;as--&nbsp;assume&nbsp;SomeTable&nbsp;exists&nbsp;with&nbsp;the&nbsp;same&nbsp;definition&nbsp;as&nbsp;#t,&nbsp;--&nbsp;and&nbsp;has&nbsp;over&nbsp;1000&nbsp;rowscreate&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int,&nbsp;b&nbsp;char(10))select&nbsp;*&nbsp;from&nbsp;#tinsert&nbsp;#t&nbsp;select&nbsp;*&nbsp;from&nbsp;SomeTableselect&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;&nbsp;where&nbsp;a&nbsp;=&nbsp;37goexec&nbsp;RowModificationsexec&nbsp;RowModifications<BR>对于&nbsp;RowModifications&nbsp;过程的第二次执行，在“事件探查器”中将看到下列事件：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;RowModifications&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int,&nbsp;b&nbsp;char(10))&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;insert&nbsp;#t&nbsp;select&nbsp;*&nbsp;from&nbsp;SomeTable&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;where&nbsp;a&nbsp;=&nbsp;37&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;RowModifications&nbsp;&nbsp;<BR>Auto-UpdateStats&nbsp;&nbsp;a&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;where&nbsp;a&nbsp;=&nbsp;37&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;RowModifications&nbsp;&nbsp;</P>
<P>备注：第一个执行过程也将显示&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;语句的&nbsp;SP:Recompile&nbsp;事件。&nbsp;在这种特定情况下，重新编译的原因将在本文的“由于交错执行数据定义语句&nbsp;(DDL)&nbsp;和数据操作语句&nbsp;(DML)&nbsp;操作引起重新编译”部分进行讨论。&nbsp;对于该示例，请注意如上所示的&nbsp;SP:Recompile，因为每次执行过程时都发生该事件。&nbsp;</P>
<P>在本例中，由于表创建以来行数已发生更改，select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;where&nbsp;a&nbsp;=&nbsp;37&nbsp;语句引起了过程的重新编译。&nbsp;Auto-UpdateStats&nbsp;事件的出现证实了重新编译是由于行修改引起的。&nbsp;Text&nbsp;列指出修改其统计数字的列。&nbsp;</P>
<P>创建&nbsp;#t&nbsp;表时，行数为零。&nbsp;原始&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;语句的计划是用该行计数产生的，对于&nbsp;select&nbsp;count&nbsp;(*)&nbsp;查询的计划也一样。&nbsp;但是在执行&nbsp;select&nbsp;count(*)&nbsp;前，1,000&nbsp;行新行插入到&nbsp;#t&nbsp;表中。&nbsp;由于大多数数据已更改，优化器将重新编译过程以确保为语句选择了效率最高的计划。&nbsp;这个重新编译在每次执行存储过程期间都发生，因为通常认为插入&nbsp;1,000&nbsp;行对于保证产生重新编译足够了。&nbsp;</P>
<P>SQL&nbsp;Server&nbsp;用来确定计划是否应重新编译的算法与用于自动更新统计的算法相同，如在下列&nbsp;Microsoft&nbsp;Knowledge&nbsp;Base&nbsp;文章所描述的：&nbsp;</P>
<P>Q195565&nbsp;INF：&nbsp;How&nbsp;SQL&nbsp;Server&nbsp;7.0&nbsp;Autostats&nbsp;Work&nbsp;<BR>在上述示例中，存储过程足够小，所以重新编译不会对性能有明显的影响。&nbsp;但是，当有大型存储过程时，如果它执行类似的活动导致多次进行重新编译，可能会注意到性能下降。&nbsp;</P>
<P>使用以下方法消除由于行修改引起的重新编译：&nbsp;<BR>使用&nbsp;sp_executesql&nbsp;执行语句。&nbsp;<BR>这是首选的方法。&nbsp;使用&nbsp;sp_executesql&nbsp;存储过程执行的语句并没有作为存储过程计划的一部分进行编译。&nbsp;因此，执行该语句时，SQL&nbsp;Server&nbsp;将可以随意选择使用语句高速缓存中的现有计划，或者在运行时创建新的计划。&nbsp;不管哪一种情况下，正在调用的存储过程的计划不会受到影响，因而无须进行重新编译。&nbsp;</P>
<P>EXECUTE&nbsp;语句有同样的效果；但是并不推荐使用它。&nbsp;使用&nbsp;EXECUTE&nbsp;语句的效率没有使用&nbsp;sp_executesql&nbsp;的高，因为它不允许进行参数化查询。&nbsp;</P>
<P>上述所给出的&nbsp;RowModifications&nbsp;过程可以使用&nbsp;sp_executesql&nbsp;进行编写，如下所示：&nbsp;</P>
<P><BR>drop&nbsp;procedure&nbsp;RowModifications2gocreate&nbsp;procedure&nbsp;RowModifications2&nbsp;asset&nbsp;nocount&nbsp;on--&nbsp;assume&nbsp;SomeTable&nbsp;exists&nbsp;with&nbsp;the&nbsp;same&nbsp;definition&nbsp;as&nbsp;#t,&nbsp;--&nbsp;and&nbsp;has&nbsp;over&nbsp;1000&nbsp;rowscreate&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int,&nbsp;b&nbsp;char(10))select&nbsp;*&nbsp;from&nbsp;#tinsert&nbsp;#t&nbsp;select&nbsp;*&nbsp;from&nbsp;SomeTableexec&nbsp;sp_executesql&nbsp;N''select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;where&nbsp;a&nbsp;=&nbsp;@a'',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N''@a&nbsp;int'',&nbsp;@a&nbsp;=&nbsp;&nbsp;37goexec&nbsp;RowModifications2exec&nbsp;RowModifications2</P>
<P>如果是第二次执行&nbsp;RowModifications2&nbsp;过程，则在“事件探查器”中看到下列事件：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;RowModifications2&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int,&nbsp;b&nbsp;char(10))&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;insert&nbsp;#t&nbsp;select&nbsp;*&nbsp;from&nbsp;SomeTable&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;exec&nbsp;sp_executesql&nbsp;N''select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;where&nbsp;a&nbsp;=&nbsp;@a'',&nbsp;N''@a&nbsp;int'',&nbsp;@a&nbsp;=&nbsp;37&nbsp;&nbsp;<BR>SP:Starting&nbsp;&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;where&nbsp;a&nbsp;=&nbsp;@a&nbsp;&nbsp;<BR>Auto-UpdateStats&nbsp;&nbsp;a&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;where&nbsp;a&nbsp;=&nbsp;@a&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;RowModifications2&nbsp;&nbsp;</P>
<P><BR>注意&nbsp;RowModifications2&nbsp;过程没有&nbsp;SP:Recompile&nbsp;事件。&nbsp;sp_executesql&nbsp;调用环境具有从&nbsp;SP:Starting&nbsp;到&nbsp;SP:Completed&nbsp;的完整事件，同时&nbsp;a&nbsp;列有&nbsp;Auto-UpdateStats&nbsp;事件。&nbsp;但是，由于该调用超出存储过程的环境，在这种情况下无须对&nbsp;RowModifications2&nbsp;过程进行重新编译。&nbsp;</P>
<P>有关使用&nbsp;sp_executesql&nbsp;存储过程的详细信息，请参见&nbsp;SQL&nbsp;Server&nbsp;7.0&nbsp;Books&nbsp;Online&nbsp;中的“sp_executesql&nbsp;(T-SQL)”和“Using&nbsp;sp_executesql”。&nbsp;<BR>使用子过程执行引起重新编译的语句。&nbsp;<BR>在这种情况下，该语句可能还会引起重新编译，但不是重新编译大型调用存储过程，而只是重新编译小型子过程。&nbsp;<BR>使用&nbsp;KEEP&nbsp;PLAN&nbsp;选项。&nbsp;<BR>临时表对于重新编译有特殊规则，在某些情况下，这些规则比默认的重新编译算法要严格得多。&nbsp;可以使用&nbsp;KEEP&nbsp;PLAN&nbsp;选项将临时表的阈值放宽到默认算法。&nbsp;有关其它信息，请参阅本文的“使用&nbsp;KEEP&nbsp;PLAN&nbsp;选项避免重新编译”部分。&nbsp;<BR>备注：RowModifications&nbsp;过程是由于行修改需要重新编译过程的一个非常简化的示例。&nbsp;请查看以下有关该示例的警告信息：&nbsp;</P>
<P><BR>尽管示例使用的是临时表，这种状况也适用于引用永久表的存储过程。&nbsp;如果引用表中的大量数据在生成查询计划以来已被更改，则重新编译存储过程。&nbsp;在本文的“使用&nbsp;KEEP&nbsp;PLAN&nbsp;选项避免重新编译”部分，讨论如何在重新编译中考虑临时表的差别。&nbsp;<BR>当在临时表&nbsp;#t&nbsp;上第一次执行&nbsp;SELECT&nbsp;操作时，上述两个过程的第一次执行也会引起重新编译。进行重新编译的原因将在本文的“由于交错执行数据定义语句&nbsp;(DDL)&nbsp;和数据操作语句&nbsp;(DML)&nbsp;操作引起重新编译”部分进行讨论。&nbsp;<BR>在本示例中使用&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;语句，而不是使用简单的&nbsp;select&nbsp;*&nbsp;from&nbsp;#t&nbsp;语句。&nbsp;为避免过多的重新编译，SQL&nbsp;Server&nbsp;不考虑因行修改重新编译“非常小的计划”（如&nbsp;select&nbsp;*&nbsp;from&nbsp;a&nbsp;table）。&nbsp;</P></FONT>