<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>存储过程</B><BR>1。返回不同的值，区别错在什么地方<BR>create&nbsp;proc&nbsp;procaddperson<BR>(@userid&nbsp;vchar(40),@name&nbsp;varchar(40),@titile&nbsp;varchar(40),@password&nbsp;varchar(40))<BR>as<BR>begin<BR>&nbsp;&nbsp;if&nbsp;exists(select&nbsp;*&nbsp;from&nbsp;tableperson&nbsp;where&nbsp;userid=@userid)<BR>&nbsp;&nbsp;begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rollback&nbsp;tran<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;10&nbsp;---人已存在<BR>&nbsp;&nbsp;end<BR>&nbsp;&nbsp;insert&nbsp;into&nbsp;tableperson(userid,name,title,password)<BR>&nbsp;&nbsp;values(@userid,@name,@title,convert(varbinary(300),@password))<BR>&nbsp;&nbsp;if&nbsp;@@error&lt;&gt;0<BR>&nbsp;&nbsp;begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rollback&nbsp;tran<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;20&nbsp;--意外错误<BR>&nbsp;&nbsp;end&nbsp;else<BR>&nbsp;&nbsp;begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;commit&nbsp;tran<BR>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1<BR>&nbsp;&nbsp;end&nbsp;<BR>2.取得自增编号，以便利用<BR>&nbsp;&nbsp;在&nbsp;insert&nbsp;后<BR>&nbsp;&nbsp;select&nbsp;@@identify&nbsp;&nbsp;<BR>3.创建临时表<BR>create&nbsp;procedure&nbsp;sumlogin&nbsp;<BR>as<BR>&nbsp;&nbsp;declare&nbsp;@count&nbsp;int<BR>&nbsp;&nbsp;set&nbsp;@count=0<BR>&nbsp;create&nbsp;table&nbsp;#temp<BR>&nbsp;&nbsp;(spid&nbsp;smallint,<BR>&nbsp;&nbsp;&nbsp;ecid&nbsp;smallint,<BR>&nbsp;&nbsp;&nbsp;status&nbsp;nchar(30),<BR>&nbsp;&nbsp;&nbsp;loginname&nbsp;nchar(128),<BR>&nbsp;&nbsp;&nbsp;hostname&nbsp;nchar(128),<BR>&nbsp;&nbsp;&nbsp;blk&nbsp;char(5),<BR>&nbsp;&nbsp;&nbsp;dbname&nbsp;nchar(128),<BR>&nbsp;&nbsp;&nbsp;cmd&nbsp;nchar(16)<BR>&nbsp;)<BR>&nbsp;&nbsp;insert&nbsp;into&nbsp;#temp&nbsp;exec&nbsp;sp_who<BR>&nbsp;&nbsp;select&nbsp;@count=count(*)&nbsp;from&nbsp;#temp&nbsp;where&nbsp;upper(dbname)=upper(''fmeca'')&nbsp;and&nbsp;<BR>&nbsp;&nbsp;status=''sleeping''<BR>&nbsp;&nbsp;return&nbsp;@count<BR>4.当存储过程返回表时，调用要用&nbsp;open而不要用execsql<BR>5。更新字段，当调用存储过程更新字段，而字段数目又不确定时<BR>&nbsp;&nbsp;&nbsp;&nbsp;有的字段要更新，有的要保留，有时要全部更新，每次更新的不一定时<BR>&nbsp;&nbsp;&nbsp;create&nbsp;proc&nbsp;updatetable&nbsp;(@f1&nbsp;varchar(100),@f2&nbsp;varchar(100)....)<BR>&nbsp;&nbsp;as<BR>&nbsp;&nbsp;&nbsp;&nbsp;update&nbsp;tabelname<BR>&nbsp;&nbsp;&nbsp;set&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field1=isnull(@f1,filed1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field2=isnull(@f2,field2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;.....<BR>&nbsp;&nbsp;&nbsp;from&nbsp;tablename&nbsp;<BR>&nbsp;&nbsp;&nbsp;当不想更新时就传null对应相应的字段。<BR>6.select&nbsp;,update&nbsp;不能直接调用存储过程，insert可以，见前面的例子<BR>7。使用带一个变量的&nbsp;EXECUTE&nbsp;''tsql_string''&nbsp;语句<BR>这个例子显示&nbsp;EXECUTE&nbsp;语句如何处理动态生成的、含有变量的字符串。这个例子创建&nbsp;tables_cursor&nbsp;游标来保存所有用户定义表&nbsp;(type&nbsp;=&nbsp;U)&nbsp;的列表。<BR>说明&nbsp;&nbsp;此例子只用作举例。<BR>DECLARE&nbsp;tables_cursor&nbsp;CURSOR<BR>&nbsp;&nbsp;&nbsp;FOR<BR>&nbsp;&nbsp;&nbsp;SELECT&nbsp;name&nbsp;FROM&nbsp;sysobjects&nbsp;WHERE&nbsp;type&nbsp;=&nbsp;''U''<BR>OPEN&nbsp;tables_cursor<BR>DECLARE&nbsp;@tablename&nbsp;sysname<BR>FETCH&nbsp;NEXT&nbsp;FROM&nbsp;tables_cursor&nbsp;INTO&nbsp;@tablename<BR>WHILE&nbsp;(@@FETCH_STATUS&nbsp;&lt;&gt;&nbsp;-1)<BR>BEGIN<BR>&nbsp;&nbsp;&nbsp;/*&nbsp;A&nbsp;@@FETCH_STATUS&nbsp;of&nbsp;-2&nbsp;means&nbsp;that&nbsp;the&nbsp;row&nbsp;has&nbsp;been&nbsp;deleted.<BR>&nbsp;&nbsp;&nbsp;There&nbsp;is&nbsp;no&nbsp;need&nbsp;to&nbsp;test&nbsp;for&nbsp;this&nbsp;because&nbsp;this&nbsp;loop&nbsp;drops&nbsp;all<BR>&nbsp;&nbsp;&nbsp;user-defined&nbsp;tables.&nbsp;&nbsp;&nbsp;*/.<BR>&nbsp;&nbsp;<B>&nbsp;EXEC&nbsp;(''DROP&nbsp;TABLE&nbsp;''&nbsp;+&nbsp;@tablename)</B>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;FETCH&nbsp;NEXT&nbsp;FROM&nbsp;tables_cursor&nbsp;INTO&nbsp;@tablename<BR>END<BR>PRINT&nbsp;''All&nbsp;user-defined&nbsp;tables&nbsp;have&nbsp;been&nbsp;dropped&nbsp;from&nbsp;the&nbsp;database.''<BR>DEALLOCATE&nbsp;tables_cursor<BR>8.访问不同的表<BR>&nbsp;&nbsp;create&nbsp;proc&nbsp;dynamictable&nbsp;&nbsp;@tablename&nbsp;&nbsp;varchar(50)<BR>as<BR>&nbsp;&nbsp;declare&nbsp;@ssql&nbsp;varchar(200)<BR>&nbsp;&nbsp;set&nbsp;@ssql=''select&nbsp;*&nbsp;from&nbsp;''+@tablename&nbsp;<BR>&nbsp;&nbsp;exec(@ssql)<BR>9.使用带远程存储过程的&nbsp;EXECUTE&nbsp;语句<BR>这个例子在远程服务器&nbsp;SQLSERVER1&nbsp;上执行&nbsp;checkcontract&nbsp;存储过程，在&nbsp;@retstat&nbsp;中保存返回状态，说明运行成功或失败。
<P></P>
<P>DECLARE&nbsp;@retstat&nbsp;int<BR>EXECUTE&nbsp;@retstat&nbsp;=&nbsp;SQLSERVER1.pubs.dbo.checkcontract&nbsp;''409-56-4008''</P>
<P>10.使用带扩展存储过程的&nbsp;EXECUTE&nbsp;语句<BR>下例使用&nbsp;xp_cmdshell&nbsp;扩展存储过程列出文件扩展名为&nbsp;.exe&nbsp;的所有文件的目录。</P>
<P>USE&nbsp;master<BR>EXECUTE&nbsp;xp_cmdshell&nbsp;''dir&nbsp;*.exe''</P>
<P>11.使用带一个存储过程变量的&nbsp;EXECUTE&nbsp;语句<BR>这个例子创建一个代表存储过程名称的变量。</P>
<P>DECLARE&nbsp;@proc_name&nbsp;varchar(30)<BR>SET&nbsp;@proc_name&nbsp;=&nbsp;''sp_who''<BR>EXEC&nbsp;@proc_name</P>
<P>12.使用带&nbsp;DEFAULT&nbsp;的&nbsp;EXECUTE&nbsp;语句<BR>这个例子创建了一个存储过程，过程中第一个和第三个参数为默认值。当运行该过程时，如果调用时没有传递值或者指定了默认值，这些默认值就会赋给第一个和第三个参数。注意&nbsp;DEFAULT&nbsp;关键字有多种使用方法。&nbsp;</P>
<P>USE&nbsp;pubs<BR>IF&nbsp;EXISTS&nbsp;(SELECT&nbsp;name&nbsp;FROM&nbsp;sysobjects&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;name&nbsp;=&nbsp;''proc_calculate_taxes''&nbsp;AND&nbsp;type&nbsp;=&nbsp;''P'')<BR>&nbsp;&nbsp;&nbsp;DROP&nbsp;PROCEDURE&nbsp;proc_calculate_taxes<BR>GO<BR>--&nbsp;Create&nbsp;the&nbsp;stored&nbsp;procedure.<BR>CREATE&nbsp;PROCEDURE&nbsp;proc_calculate_taxes&nbsp;(@p1&nbsp;smallint&nbsp;=&nbsp;42,&nbsp;@p2&nbsp;char(1),&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@p3&nbsp;varchar(8)&nbsp;=&nbsp;''CAR'')<BR>&nbsp;&nbsp;&nbsp;&nbsp;AS&nbsp;<BR>&nbsp;&nbsp;&nbsp;SELECT&nbsp;*&nbsp;<BR>&nbsp;&nbsp;&nbsp;FROM&nbsp;mytable<BR>13.使用多个参数与一个输出参数<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>[B]&nbsp;存储过程的return好像只能返回整数，要想返回浮点数，要用output</B>[/B]<BR>&nbsp;&nbsp;&nbsp;&nbsp;这个例子执行&nbsp;roy_check&nbsp;存储过程，传递三个参数。第三个参数&nbsp;@pc&nbsp;是输出参数。过程&nbsp;执行完后，返回变量可以从变量&nbsp;@percent&nbsp;得到。</P>
<P>说明&nbsp;&nbsp;roy_check&nbsp;存储过程只是用作举例，pubs&nbsp;数据库中并没有此过程。<BR>DECLARE&nbsp;@percent&nbsp;int<BR>EXECUTE&nbsp;roy_check&nbsp;''BU1032'',&nbsp;1050,&nbsp;@pc&nbsp;=&nbsp;@percent&nbsp;OUTPUT<BR>SET&nbsp;Percent&nbsp;=&nbsp;@percent</P></FONT>