<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>DTS包属性(2)</B><BR>本文节选自铁道出版社最近出版的<BR>《SQL&nbsp;Server&nbsp;2000&nbsp;完全实战:数据转换服务（DTS）》由章立民编著<BR>版权属以上两者所有，请不要转载。
<P></P>
<P>一个步骤要能够加入包事务，其DTS连接的数据来源必须支持分布式事务。比方说，如果一个步骤的DTS连接系连接至Microsoft?&nbsp;SQL&nbsp;Server，它就可以加入包事务；如果一个步骤的DTS连接系连接至Microsoft?&nbsp;Access&nbsp;2000，它将不能加入包事务。尝试将一个使用不被支持之DTS连接的步骤加入包事务，于执行时期将会发生错误。<BR>以下所列的数据来源支持分布式事务<BR>&nbsp;&nbsp;&nbsp;&nbsp;Microsoft&nbsp;OLE&nbsp;DB&nbsp;Provider&nbsp;for&nbsp;SQL&nbsp;Server<BR>ODBC数据来源<BR>&nbsp;&nbsp;&nbsp;&nbsp;ODBC驱动程序必须支持连接属性SQL_ATT_ENLIST_IN_DTS而且此属性务必加以设置。<BR>Microsoft&nbsp;Data&nbsp;Link<BR>&nbsp;&nbsp;&nbsp;&nbsp;Microsoft&nbsp;Data&nbsp;Link系被用来访问任何已安装的OLE&nbsp;DB&nbsp;Provider。一个OLE&nbsp;DB&nbsp;Provider要想加入分布式事务中，它必须采用ITransactionJoin接口。<BR>一般来说，于DTS包中使用事务的整个设置流程如下所示：<BR>1.&nbsp;&nbsp;&nbsp;&nbsp;启用事务<BR>&nbsp;&nbsp;&nbsp;&nbsp;要能够在DTS包中使用事务的第一件事，就是必须如图表2-44所示，于「DTS包属性」对话框的「高级」页面中，勾选复选框&nbsp;□&nbsp;使用事务，此举表示允许在DTS包中定义及使用任务的事务单元；如果您并未勾选此复选框，将没有任何的包事务会被建立，而且步骤要求加入事务的请求亦会被忽略。<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>图表2-44<BR>2.&nbsp;&nbsp;&nbsp;&nbsp;将某一个步骤加入包事务<BR>&nbsp;&nbsp;&nbsp;&nbsp;欲将某一个步骤加入包事务，请开启该步骤的「工作流属性」对话框并切换至「选项」页面，然后勾选复选框&nbsp;□有事务时联接（如图表2-45所示）。此举会将此步骤加入包事务，而且更新将会一直累积直到认可或复原为止。<BR>当一个步骤加入包事务，此步骤所使用的每一个DTS连接也都会加入分布式事务中。这种DTS连接的所有更新将会累积在包事务中，即使它们起源于一个并未加入包事务的步骤。因此，欲于一个包中针对同一个数据库执行事务与非事务的更新，必须使用两个DTS连接。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>图表2-45<BR>3.&nbsp;&nbsp;&nbsp;&nbsp;反复步骤2的操作，直到您已将所需的各个步骤加入包事务为止。<BR>4.&nbsp;&nbsp;&nbsp;&nbsp;认可或复原<BR>&nbsp;&nbsp;&nbsp;&nbsp;当包事务被认可，所有累积的更新将会实际写入。当发生下列事件之一时，包事务便会被认可：<BR>一个步骤成功地完成而且复选框&nbsp;□成功完成此步骤时提交事务&nbsp;被勾选（此复选框位于「工作流属性」对话框的「选项」页面中）。<BR>包成功地完成而且复选框&nbsp;□&nbsp;成功完成包时提交&nbsp;被勾选（此复选框位于「DTS包属性」对话框的「高级」页面中）。<BR>&nbsp;&nbsp;&nbsp;&nbsp;当包事务被复原，所有累积的更新将会被恢复而视同没有发生过。当发生下列事件之一时，包事务便会被复原：<BR>&nbsp;&nbsp;&nbsp;&nbsp;包&nbsp;&nbsp;执行失败。<BR>包执行完毕但是该包的&nbsp;□&nbsp;成功完成包时提交&nbsp;复选框并未被勾选。<BR>某一个步骤执行失败而且该步骤的&nbsp;□&nbsp;失败时回滚事务&nbsp;复选框被勾选（此复选框位于「工作流属性」对话框的「选项」页面中）。<BR>继承的事务<BR>我们可以在DTS包之工作流的某一个步骤以执行包任务去执行其它的DTS包，内含执行包任务的包称为「父包」（Parent&nbsp;Package），而被执行包任务所执行的包则称为「子包」（Child&nbsp;Package）。子包可以建立它自己的包事务，抑或是继承父包事务。<BR>当下列两项条件皆成立时，子包就可继承父包事务：<BR>子包系被一个执行包任务所调用。<BR>调用子包的执行包任务亦加入父包事务中。<BR>如图表2-46所示，其中的6个包全部使用事务。每一个包其实都内含数个任务，但是我们仅标示出执行包任务。包A执行包B与C，包B与C则依序执行包D、E与F。已加入包事务的执行包任务会被加上底线。<BR>包A、B与D会在一个包事务中执行；包C与F会在第二个包事务中执行；包E则拥有它自己个别的包事务。<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>图表2-46<BR>如果以继承的事务执行包，事务行为将有很大的不同，说明如下：<BR>不会有任何新的包事务被启动。步骤会加入继承的父事务中。<BR>不会进行任何认可。特别是：<BR>如果复选框&nbsp;□&nbsp;成功完成此步骤时提交事务&nbsp;被勾选，则会忽略父事务。<BR>如果复选框&nbsp;□&nbsp;成功完成包时提交&nbsp;被勾选，则会忽略父事务。<BR>当包完成时不会进行任何复原，即使包执行失败亦是如此。然而，如果您勾选「工作流属性」对话框中的复选框&nbsp;□&nbsp;失败时将事务复原，个别的步骤可能会复原父包事务。<BR>如果一个子包失败，则执行它的执行包任务也会失败。如果一个子包成功地完成，则执行它的执行包任务也会成功地完成。如果一个子包发生许多错误或复原包事务，但是并未勾选其复选框&nbsp;□第一次出错时使包失败（此选项位于「DTS包属性」对话框的「日志记录」页面中），它将会成功地完成，执行它的执行包任务也会成功地完成。</P>
<P>事务隔离层级<BR>先前定义事务时就曾提及，"隔离"是事务的特性之一，本段落我们就要说明如何去设置事务隔离层级。隔离层级亦指事务准备去接受不一致数据的层级。替您的包设置正确的隔离层级是非常重要的。<BR>隔离层级是一个事务与其它事务隔离的程度。较低的隔离层级可以增加并行性，但却会牺牲数据的正确性。反之，较高的隔离层级可以确保数据是正确的，但会减低并行性。<BR>并行性意指当一个用户去修改数据的同时其它用户目前亦正在修改该数据。您可以透过悲观式并行性或乐观式并行性来解决此一状况。<BR>悲观式并行性会去锁定它所欲读取或更新的数据，而且直到它离开该笔数据时才会解除锁定。因此，锁定的时间可能很长，不过此举可以确保当您在读取该数据时没有任何其它用户能够修改它。<BR>乐观式并行性则是在对数据进行写入时才会去锁定它，因此，您无法确认数据在您读取与更新时是否相同。虽然如此，乐观式并行性只会锁定数据很短的时间，因此有助于数据共享。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>图表2-47<BR>您可以如图表2-47所示，从「事务隔离层级」下拉列表中选取一选项来设置隔离层级。透过设置事务隔离层级，可以决定在事务外部的异动有多大范围是事务可见的。特别值得一提的是，事务隔离层级是由是否出现下列现象所定义：<BR>Dirty读取（Dirty&nbsp;Read）<BR>&nbsp;&nbsp;&nbsp;&nbsp;Dirty读取意指一个事务读取了未被认可的数据。举例来说，假设事务1更改了一笔数据记录，事务2在事务1认可它所做的修改前读取了该笔已修改的数据记录，如果事务1放弃该项更新，事务2就会读取到逻辑上被视为是不存在的数据记录。<BR>&nbsp;&nbsp;&nbsp;&nbsp;非可重复读取（Nonrepeatable&nbsp;read）<BR>&nbsp;&nbsp;&nbsp;&nbsp;非可重复读取意指当一个事务读取相同的数据记录超过一次以上，而在两次或多次的读取之间有另外一个事务修改此笔数据记录的内容。由于在相同事务内的多次读取之间数据记录已被修改，使得每次读取到不同的数据值，因而造成不一致的问题。<BR>&nbsp;&nbsp;&nbsp;&nbsp;举例来说，假设事务1读取一笔数据记录，事务2修改或删除了该笔数据记录并认可所做的修改或删除，如果事务1尝试再次读取该笔数据记录，所提取的将是不同的数据值或是发现该笔数据记录已被删除。<BR>幻像（Phantom）<BR>&nbsp;&nbsp;&nbsp;&nbsp;某一个任务读取了某一范围的数据记录且尚未认可，尔后有另外一个任务在此范围中新建了一笔数据记录或删除某一笔既存的数据记录，此举将因为该范围中的记录笔数已经改变而导致未认可该事务的任务无法重复其原先的读取作业。如果一个连接将其事务隔离层级设置成Serializable，SQL&nbsp;Server将使用索引键范围锁定来防止幻像。<BR>&nbsp;&nbsp;&nbsp;&nbsp;举例来说，事务1搜寻出符合特定条件的多笔数据记录以便加以读取，尔后事务2新建了一笔符合事务1之搜寻条件的数据记录，如果事务1再次执行搜寻命令，搜寻所得的数据记录将与先前不尽相同。<BR>以下是「事务隔离层级」下拉列表中各个选项的说明：<BR>Chaos<BR>&nbsp;&nbsp;&nbsp;&nbsp;此选项只有当您在DTS中使用非SQL&nbsp;Server数据来源时才会使用到，而且它亦是最危险的选项。如果您的DTS包写入任何数据，而且没有出现任何错误，您将不能够复原所做的更新－－亦即一旦建立就没有办法被恢复。因此，一个以Chaos层级作业的DTS任务事务并无法将您与其它正在使用数据来源的任务单元隔离开来，因此您包中的事务将会见到其它事务所有未认可的异动。如果其它事务后来复原了它们的异动，您的DTS包将不会受影响而且会如同数据已被认可般的继续执行。此外，包执行的任何更新锁定将不会持续到事务结束。<BR>&nbsp;&nbsp;&nbsp;&nbsp;Read&nbsp;Committed<BR>&nbsp;&nbsp;&nbsp;&nbsp;我想这是您最经常使用到的选项，它提供您包最高等级的数据完整性。一个以此隔离层级运行的包不会见到其它事务所做的异动，直到这些事务已认可为止。在此隔离层级中，不可能发生Dirty读取，但是非可重复读取与幻像则是可能发生的。<BR>Read&nbsp;Uncommitted<BR>&nbsp;&nbsp;&nbsp;&nbsp;此选项与Chaos选项有点类似，然而此选项可适用于SQL&nbsp;Server。一个以此隔离层级运行的包将能够见到其它事务所做的异动。在此隔离层级中，Dirty读取、非可重复读取与幻像都是可能发生的。<BR>Repeatable&nbsp;Read<BR>&nbsp;&nbsp;&nbsp;&nbsp;一个以Repeatable&nbsp;Read隔离层级运行的DTS包可保证包内的每一个事务不会见到其它事务对已读取之数据值所做的任何异动。因此，如果一个事务读取相同的数据两次，它将固定见到原始数据。在此隔离层级中，不会发生Dirty读取与非可重复读取，然而幻像则是可能发生的。<BR>Serializable<BR>&nbsp;&nbsp;&nbsp;&nbsp;一个以Serializable隔离层级运行的DTS包可保证所有并行事务交互所产生的结果与个别完整执行每个事务的结果一样。在此隔离层级中，&nbsp;Dirty读取、非可重复读取与幻像皆不会发生。<BR>OLE&nbsp;DB<BR>如果您勾选复选框&nbsp;□&nbsp;使用OLE&nbsp;DB服务组件，表示使用OLE&nbsp;DB服务组件（预设为IDataInitialize::CreateDBInstance）来启始OLE&nbsp;DB&nbsp;Provider数据来源；如果您不勾选复选框&nbsp;□&nbsp;使用OLE&nbsp;DB服务组件，表示直接以CoCreateInstance来启始数据来源对象。<BR>OLE&nbsp;DB服务组件可提供类似任务阶段共享（Session&nbsp;Pooling）与IRowsetChange的服务，但有些OLE&nbsp;DB&nbsp;Provider可能不支持这类服务。DTS提供者（PackageDSO、RowQueue与FlatFile）以及OLE&nbsp;DB&nbsp;Provider&nbsp;for&nbsp;SQL&nbsp;Server会忽略此一设置</P></FONT>