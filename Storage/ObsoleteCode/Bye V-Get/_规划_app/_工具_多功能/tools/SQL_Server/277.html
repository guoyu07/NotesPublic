<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>不等连接(ccat)</B><BR><IMG 
src="http://www.pigtwo.com/forum/pic/url.gif" align=absMiddle border=0><A 
href="http://www.csdn.net/develop/read_article.asp?id=14591" 
target=_blank>http://www.csdn.net/develop/read_article.asp?id=14591</A><BR>通常来说，SQL语言进行的都是无序操作。想要进行有序的处理，比如比较一个序列的前后项，必须要使用游标。但是，在有些场合下，可采用另一种方法，不用游标，一样能处理有序的信息，这就是不等联接。先看下面一个例子
<P></P>
<P>前一阵，&nbsp;CSDN网友BuildIt来信，和我讨论了这样的问题：以下表HISTORY</P>
<P>CREATE&nbsp;TABLE&nbsp;[HISTORY]&nbsp;(</P>
<P>[TheDate]&nbsp;[datetime]&nbsp;NULL&nbsp;,</P>
<P>[Quantity]&nbsp;[int]&nbsp;NULL&nbsp;</P>
<P>)&nbsp;ON&nbsp;[PRIMARY]</P>
<P>中存储的是一系列的历史数据，例如：</P>
<P>INSERT&nbsp;HISTORY&nbsp;valueS('2002-01-01&nbsp;00:00:00.0',11)</P>
<P>GO</P>
<P>INSERT&nbsp;HISTORY&nbsp;valueS('2002-01-02&nbsp;00:00:00.0',34)</P>
<P>GO</P>
<P>INSERT&nbsp;HISTORY&nbsp;valueS('2002-01-03&nbsp;00:00:00.0',27)</P>
<P>GO</P>
<P>INSERT&nbsp;HISTORY&nbsp;valueS('2002-01-04&nbsp;00:00:00.0',43)</P>
<P>GO&nbsp;</P>
<P>现在，我们要查询自起始日期至每一个日期的总量。也就是说，显示这样一个结果集：</P>
<P>TheDate&nbsp;Quantity&nbsp;q_sum</P>
<P>2002-01-01&nbsp;00:00:00.0&nbsp;11&nbsp;11</P>
<P>2002-01-02&nbsp;00:00:00.0&nbsp;34&nbsp;45</P>
<P>2002-01-03&nbsp;00:00:00.0&nbsp;27&nbsp;72</P>
<P>2002-01-04&nbsp;00:00:00.0&nbsp;43&nbsp;115</P>
<P>直观上来讲，我们可以在SELECT&nbsp;*&nbsp;FROM&nbsp;HISTORY&nbsp;ORDER&nbsp;BY&nbsp;TheDate上建一个游标，从第一条开始，每一条，加一次。那换个想法呢？如果我们建立这样一个结果集，让每一个日期限，都对应它当天的数量及所有在它之前的数量记录。那么我们就可以按这个日期分组，对数量进行求和。很显然，一个不等查询就这样形成了。我最初的写法有错误，以下是经&nbsp;BuildIt&nbsp;修改后最终的语句</P>
<P>select&nbsp;l.TheDate,</P>
<P>l.quantity,</P>
<P>sum(r.quantity)&nbsp;as&nbsp;q_sum</P>
<P>from&nbsp;HISTORY&nbsp;l</P>
<P>join&nbsp;HISTORY&nbsp;r</P>
<P>on&nbsp;l.TheDate&nbsp;&gt;=&nbsp;r.TheDate</P>
<P>group&nbsp;by&nbsp;l.TheDate,&nbsp;l.quantity</P>
<P>order&nbsp;by&nbsp;l.TheDate</P>
<P>不等联接本身就不是一一对应，它的对应关系和顺序有着密切的关系。这也就是我们能够拿它来进行有序操作的原因。再给一个很自然的例子：</P>
<P>SELECT&nbsp;L.I,&nbsp;SUM(R.I)</P>
<P>FROM&nbsp;N&nbsp;L</P>
<P>JOIN&nbsp;N&nbsp;R</P>
<P>ON&nbsp;L.I&nbsp;&gt;=R.I</P>
<P>GROUP&nbsp;BY&nbsp;L.I</P>
<P>表N只有一个整型列I，保存自然数列。所以，没什么神秘，这就是求自然数列的和。这里SUM(R.I)表示自然数列N从零至I的累加和，比前面的那个问题还要简单。不过显然这不是不等联接发挥威力的地方，因为它会形成一个巨大的三角形数据集，就像下面这样</P>
<P>1&nbsp;1</P>
<P>2&nbsp;1</P>
<P>2&nbsp;2</P>
<P>3&nbsp;1</P>
<P>3&nbsp;2</P>
<P>3&nbsp;3</P>
<P>...</P>
<P>当我对十六位整型的列表执行这个查询时，我的AthlonXP1700+/256MDDR的机器足足运行了近三十分钟，当我写下现在这段文字时，它返回了一个数据溢出错误。显然，对于这个查询，即使是十六位整数的列表，也太大了。我的建议是，仅当结果集无法用公式表达时，使用不等联接。像这个累加，我们早已有了成熟的公式，何必再让计算机傻算呢？用下面这个语句</P>
<P>SELECT&nbsp;I,&nbsp;((1+I)*I)/2&nbsp;</P>
<P>FROM&nbsp;N</P>
<P>相比老老实实地累加，速度奇快。发现数据溢出时，连一秒钟都不到，可这台计算机就是想不到用这个方法，唉……</P>
<P>传说数学界一代宗师高斯小学的时候，他老师考过他这个问题。所以几乎所有的中国小学生，都被老师用这道题折磨过。好像老师们的目的就在于告诉我们，我们的智商比不上高斯。可我压根就没想和人家比啊……</P>
<P>上大学时，教我们第一本《数学分析》的范先令老师说计算机是傻子，我当时只是觉得好玩而已，今天算是见识了，看来在归纳总结的能力方面，计算机也就是我小学时的水平，永远也赶不上高斯上小学那会儿了。</P>
<P>不过，这种东西用于公式难以表达的地方，还是有意义的。比如我的一个朋友用不等联接写过一个素数筛子，很有趣。它虽说不会比我们用过程化的代码写出来的程序效率更高，但却能把筛法根本的精要表达的清清楚楚，也许以后我们研究数论，会用的上这种SQL风格的表示法呢。这位朋友教了我很多计算机方面的知识，出于对他的尊重，我不会抄录他的代码。不过这个语句本身并不复杂，相信朋友们想到用联接查询后，都一定写得出来，大家有兴趣的话，自己不妨试试。用它还可以实现其它的一些数列，以后我们再讨论几个。</P>
<P>不等联接还有一个用法，可以用它生成一个序号列，比如</P>
<P>SELECT&nbsp;COUNT(L.AFIELD)&nbsp;AS&nbsp;ID,</P>
<P>L.AFIELD</P>
<P>FROM&nbsp;MYTABLE&nbsp;L</P>
<P>JION&nbsp;MYTABLE&nbsp;R</P>
<P>ON&nbsp;L.AFIELD&nbsp;&gt;&nbsp;R.AFIELD</P>
<P>GROUP&nbsp;BY&nbsp;L.AFIELD</P>
<P>AFIELD字段可以是字符串、日期，当然也可以是数值，反正可排序就行。这东西有点奇技淫巧的味道，数据量太大，就不好玩了，一般还是用物理行号的好，虽说不是SQL标准，但实用啊。这个例子我在MCDBA的复习题中见过（据说这道题考过），不过我的那位朋友自己就做出来过，大家可能也有独立实现过这一方法的吧。</P>
<P>不等查询的有序操作能力，显然来自联接字段的可排序和互异性，所以，最好不要在有重复值的字段上做不等联接（事实上，最好不要在有重复值的字段上做任何联接，除非你非常肯定你在干什么）。等值联接出现数据爆炸就够可怕的了，不等联接要是玩爆了……嘿嘿嘿……</P>
<P>想像一个等值联接中有一对重复值，可能出现两对重复结果。不过要是不等联接，就和重复的位置有关了。因为这是一个三角形，所以出现在最上面还好，要是出现在这个三角形的下部……</P>
<P>不等联接查询，显然是一个有力的工具，但它也是招来麻烦的快捷方式之一。有几个建议，是我的经验：<BR>如果联接会生成很大的“三角形”，就不要用，试试子查询或哪怕游标；</P>
<P>生成的结果集相对于原表越小越好，尽可能地把无用的数据先过滤掉；</P>
<P>用不等联接进行数列计算会表达的很清楚（因为是非过程化的），但通常在效率上它没有什么优势，所以，平时玩玩可以，真用的话最好先考虑好；</P>
<P>还有就是不等联接不要轻易用在多重联接中，否则可能会引起杠杆作用。</P>
<P>祝大家在这个神奇的世界中旅行愉快！<BR></P></FONT>