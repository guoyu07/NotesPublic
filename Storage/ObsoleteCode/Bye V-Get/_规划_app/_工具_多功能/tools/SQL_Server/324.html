<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>SQLMail的原理及实际应用(batman)</B><BR>SQLMail的原理及实际应用
<P></P>
<P>-概述</P>
<P>----这里所指的SQLMail，是微软公司的关系数据库管理系统<BR>SQLServer所提供的邮件功能。在SQLServer中包含一些扩展存储<BR>过程，使得SQLServer可以通过基于WindowsNT内部的消息应用编<BR>程界面（MAPI）的客户机邮件程序接收和发送邮件消息。SQLMa<BR>il可发送的消息包括文本串，附加文件或SQL语句的执行结果<BR>集。应用SQLMail的扩展存储过程，邮件消息可以从一个触发<BR>器或一个存储过程中发送，并且通过SQLServer提供的任务和警<BR>告等功能，可以根据需要在不同的时间和情况下发送。</P>
<P>----SQLMail工作流程</P>
<P>----SQLMail工作流程主要分为邮件收、发两个过程。</P>
<P>----在SQLServer内可以通过一定方法，调用扩展存储过程xp_s<BR>endmail，将收信人电子邮件地址，标题，信的内容等以参数的<BR>形式传送给xp_sendmail，由它通过客户端MAPI接口将发送邮件任<BR>务交给如MicrosoftExchangeClient或Outlook97等邮件客户端程序，<BR>最终通过邮件服务将邮件发送出去。</P>
<P>----收邮件的过程与此相似。在SQLServer端定期或手工调用x<BR>p_readmail扩展存储过程，通过客户端MAPI接口将存放在邮件服<BR>务器或客户端的邮件及其他信息读入SQL变量中，用来满足特<BR>定的处理需要。<BR>配置SQLMail</P>
<P>----配置SQLMail的首要条件是要有一个电子邮件帐户，不管<BR>是局域网内的MSExchangeServer或MSMail3.x的邮件帐户，还是Int<BR>ernet上的SMTP，POP3等邮件帐户均可。具体配置可分为以下几步<BR>：</P>
<P>----1．为SQLServer创建一个NT域用户帐号，要求具有本地管<BR>理员组的权限。仔细设置帐号口令，保证口令足够复杂，且<BR>设成口令永不过期和用户不得更改口令。</P>
<P>----2．双击控制面板的服务图标，找到MSSQLServer的启动设<BR>置，将UseSystemAccount改为UseThisAccount，将刚才建立的NT帐号<BR>和口令输入。重新启动SQLServer。</P>
<P>----3．在安装SQLServer的服务器上以与启动SQLServer相同的<BR>NT帐号登录，然后安装支持MAPI接口的邮件客户端程序，如MS<BR>ExchangeClient和Outlook97。</P>
<P>----4．打开控制面板的电子邮件选项，建立一个配置文件<BR>（Profile）。用这个配置文件启动邮件客户端程序，反复检验<BR>直至能正常收发邮件。</P>
<P>----5．从SqlEnterpriserManager中，点中相应的服务器图标，从<BR>Server菜单中选SQLMail/Configure，将在第4步中建立的配置文件<BR>名输入。</P>
<P>----6．从SqlEnterpriserManager中，点中相应的服务器图标，从<BR>Server菜单中选SQLMail/Start，如果SqlMail的图标变为绿色，则SQ<BR>LMail成功启动。</P>
<P>----常用的SQLMail扩展存储过程</P>
<P>xp_sendmail@recipient=recipient</P>
<P>[;recipient2;][...;recipientn]]</P>
<P>[,@message=message]</P>
<P>[,@query=query]</P>
<P>[,@attachments=attachments]</P>
<P>[,@copy_recipients=recipient</P>
<P>][;recipient2;][...;recipientn]]]</P>
<P>[,@blind_copy_recipients=recipient</P>
<P>][;recipient2;][...;recipientn]]]</P>
<P>[,@subject=subject]</P>
<P>[,@type=type]</P>
<P>[,@attach_results={'true'|'false'}]</P>
<P>[,@no_output={'true'|'false'}]</P>
<P>[,@no_header={'true'|'false'}]</P>
<P>[,@width=width]</P>
<P>[,@separator=separator]</P>
<P>[,@echo_error={'true'|'false'}]</P>
<P>[,@set_user=user]</P>
<P>[,@dbuse=dbname]</P>
<P>----此存储过程通过客户端MAPI接口发送邮件，内容可以是<BR>文本串，附加文件或SQL语句的执行结果集。</P>
<P>xp_findnextmsg[@msg_id=msg_id][OUTPUT]]</P>
<P>[,@type=type]</P>
<P>[,@unread_only={'true'|'false'}])</P>
<P>----此存储过程在邮箱中查找特定的邮件，并返回一封邮件<BR>的消息ID。</P>
<P>xp_readmail([@msg_id=msg_id][,@type=type][OUTPUT]]</P>
<P>[,@peek={'true'|'false'}]</P>
<P>[,@suppress_attach={'true'|'false'}]</P>
<P>[,@originator=@senderOUTPUT]</P>
<P>[,@subject=@subject_lineOUTPUT]</P>
<P>[,@message=@body_of_messageOUTPUT]</P>
<P>[,@recipients=@recipient_listOUTPUT]</P>
<P>[,@cc_list=@cc_listOUTPUT]</P>
<P>[,@bcc_list=@bcc_listOUTPUT]</P>
<P>[,@date_received=@dateOUTPUT]</P>
<P>[,@unread={'true'|'false'}]</P>
<P>[,@attachments=@temp_file_pathsOUTPUT])</P>
<P>[,@skip_bytes=@bytes_toskipOUTPUT]</P>
<P>[,@msg_length=@length_in_bytesOUTPUT])</P>
<P>----此存储过程从指定的邮件收件箱中读取指定消息ID的邮<BR>件的各项信息。</P>
<P>----xp_deletemail[@msg_id=]msg_id</P>
<P>----从邮件收件箱中删除一封指定消息ID的邮件。</P>
<P>----注释：</P>
<P>----1.存储过程的多个参数间用逗号间隔开，[]内的为可选<BR>参数，每个参数均以@符号加字符串开头，用以区别不同的参<BR>数项。等号后可以是常量，也可以是预先定义好的变量。</P>
<P>----2.如果需要将某个结果值赋予参数中预先定义好的变<BR>量，就必须在该项参数的最后加OUTPUT。</P>
<P>----3.常用参数解释：</P>
<P>----?@recipient=recipient；指定收件人的电子邮件地址。如<BR>果有多个收件人，可以用分号分隔开。</P>
<P>----?@subject=subject；邮件的标题。发送邮件时的默认值为<BR>"SQLServerMessage"。</P>
<P>----?@message=message；邮件的具体内容。</P>
<P>----?@attachments=attachments；邮件挂接的附加文件名。</P>
<P>----?@type=type；基于MAPI定义的消息类型，详细信息参见"<BR>MicrosoftWindowsNTResourceKit"或"MicrosoftMailTechnicalReference"。</P>
<P>----?@query=query；一条SQL可执行语句，其执行结果以正文<BR>或附件的方式随邮件发送。</P>
<P>----?@msg_id=msg_id；对于信箱中的每一封邮件均被分配了</P>
<P>----?@attachments=attachments；邮件挂接的附加文件名。</P>
<P>----?@type=type；基于MAPI定义的消息类型，详细信息参见"<BR>MicrosoftWindowsNTResourceKit"或"MicrosoftMailTechnicalReference"。</P>
<P>----?@query=query；一条SQL可执行语句，其执行结果以正文<BR>或附件的方式随邮件发送。</P>
<P>----?@msg_id=msg_id；对于信箱中的每一封邮件均被分配了<BR>一个特殊的消息ID，用以相互区分。</P>
<P>----?@originator=@sender；读取特定邮件的发送者的邮件地<BR>址。</P>
<P>--基于SQLMail的电子报刊自动处理系统</P>
<P>----这里利用SQLMail简单的实现了一个电子报刊自动处理系<BR>统。每当新的一期电子报刊编辑完成，只需简单追加到发行<BR>数据库publication中，SQLServer会自动定期执行my_publish存储过<BR>程。在my_publish存储过程中，它检查发行数据库，当发现有新<BR>的记录（即新的一期电子报刊）时，就通过逐个从订阅数据库<BR>sub_info中取出订阅人的邮件地址，完成给每个订阅者发送电<BR>子报刊（以邮件形式）的任务。</P>
<P>----电子报刊的订阅与取消也是通过邮件来实现。SQLServer<BR>同样定期执行my_subscibe存储过程。my_subscibe存储过程检查特定<BR>邮箱中的所有邮件，如果存在标题为"subscribe"的邮件，就取<BR>出它的发件人等信息，在订阅数据库中添加一条记录；同样，<BR>如果存在标题为"stopsubscribe"的邮件，就将它的相关记录从<BR>订阅数据库中删除。系统中用到的数据库和存储过程如下所<BR>示。sub_info（订阅者信息数据库）</P>
<P>字段名称类型允许空值含义</P>
<P>emailvarchar(20)NOTNULL订阅者电子邮件地址</P>
<P>sub_datedatetimeNOTNULL订阅时间</P>
<P>othertextNULL订阅者的其他信息</P>
<P>publication（电子报刊出版数据库）</P>
<P>字段名称类型允许空值含义</P>
<P>pub_classchar(10)NOTNULL电子报刊期号</P>
<P>pub_datedatetimeNULL出版日期</P>
<P>titletextNOTNULL本期电子报刊标题</P>
<P>contenttextNOTNULL电子报刊正文</P>
<P>endnotetextNULL附加于报刊的其他信息</P>
<P>flagsmallintNULL1，标志为未出版的新报刊</P>
<P>my_subscribe，用于处理订阅者信息的存储过程。</P>
<P>CREATEPROCEDUREmy_subscribe</P>
<P>AS</P>
<P>declare@msg_idvarchar(64)</P>
<P>declare@subjectvarchar(255)</P>
<P>declare@messagevarchar(255)</P>
<P>declare@originatorvarchar(255)</P>
<P>declare@datevarchar(255)</P>
<P>declare@statusint</P>
<P>declare@mapifailureint</P>
<P>select@mapifailure=0</P>
<P><BR>while(1=1)</P>
<P>begin</P>
<P>/*查找邮件并获取消息ID*/</P>
<P>exec@status=master..</P>
<P>xp_findnextmsg@msg_id=@msg_idOUTPUT</P>
<P>if@status&lt;&gt;0</P>
<P>begin</P>
<P>select@mapifailure=1</P>
<P>break</P>
<P>end</P>
<P>if@msg_idisnullbreak</P>
<P>/*读取邮件的信息到变量中*/</P>
<P>exec@status=master..xp_readmail</P>
<P>@msg_id=@msg_id,</P>
<P>@originator=@originatorOUTPUT,</P>
<P>@subject=@subjectOUTPUT,</P>
<P>@message=@messageOUTPUT,</P>
<P>@date_received=@dateOUTPUT</P>
<P>if@status&lt;&gt;0</P>
<P>begin</P>
<P>select@mapifailure=1</P>
<P>break</P>
<P>end</P>
<P>/*根据邮件标题，在订阅数据库中添加或删除记录*/</P>
<P>execxp_deletemail@msg_id=@msg_id</P>
<P>if@subject='subscribe'</P>
<P>insertintosqlmailsample..</P>
<P>sub_infovalues(@originator,@date,@message)</P>
<P>else</P>
<P>if@subject='stopsubscribe'</P>
<P>deletefromsqlmailsample..sub_infowhereemail=@originator</P>
<P>end/*循环结束*/</P>
<P><BR>if@mapifailure=1</P>
<P>/*错误处理代码*/</P>
<P>else</P>
<P>return(0)</P>
<P>GO</P>
<P><BR>my_publish，用于分发电子报刊的存储过程。</P>
<P>CREATEPROCEDUREmy_publish</P>
<P>AS</P>
<P>declare@recipientvarchar(255)</P>
<P>declare@subjectvarchar(255)</P>
<P>declare@contentvarchar(255)</P>
<P>declare@endnotevarchar(255)</P>
<P>declare@statusint</P>
<P><BR>select@subject=pub_classfrom</P>
<P>sqlmailsample..publicationwhereflag=1</P>
<P>/*如果有新的电子报刊，则开始分发*/</P>
<P>if(@subjectisnotnull)</P>
<P>begin</P>
<P>/*将数据库记录取出，经过适当处理后，存放到变量中*/</P>
<P>select@subject=convert(varchar</P>
<P>(255),title)+'('+pub_class+')',</P>
<P>@content=convert(varchar(255),content)</P>
<P>+convert(varchar(255),endnote)</P>
<P>fromsqlmailsample..publication</P>
<P>whereflag=1</P>
<P>updatesqlmailsample..publication</P>
<P>setflag=0whereflag=1</P>
<P><BR>declarecurcursorforselect</P>
<P>emailfromsqlmailsample..sub_info</P>
<P>opencur</P>
<P>fetchcur</P>
<P>while(@@fetch_status=0)</P>
<P>begin</P>
<P>/*取收件人的电子邮件地址*/</P>
<P>fetchnextfromcurinto@recipient</P>
<P>/*发送电子邮件*/</P>
<P>if@@fetch_status=0</P>
<P>begin</P>
<P>exec@status=master..xp_sendmail</P>
<P>@recipients=@recipient,</P>
<P>@message=@content,</P>
<P>@subject=@subject</P>
<P>if@status&lt;&gt;0</P>
<P>/*错误处理代码*/</P>
<P>end</P>
<P>end/*向所有订阅人发送电子报刊的循环结束*/</P>
<P>closecur</P>
<P>deallocatecur</P>
<P>end</P>
<P>GO</P>
<P>----总之，SQLMail在数据库和电子邮件之间架起了一座沟通</P>
<P>end/*向所有订阅人发送电子报刊的循环结束*/</P>
<P>closecur</P>
<P>deallocatecur</P>
<P>end</P>
<P>GO</P>
<P>----总之，SQLMail在数据库和电子邮件之间架起了一座沟通<BR>的桥梁，为某些特定用途的应用提供了简单高效的解决方案<BR>，值得一试</P></FONT>