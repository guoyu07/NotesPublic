<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>关于SQLDMO的一点资料</B><BR>编写数据库脚本<BR>作者：Andrew&nbsp;Clinick
<P></P>
<P>发表日期：2000&nbsp;年&nbsp;1&nbsp;月&nbsp;10&nbsp;日</P>
<P>我在“If&nbsp;It&nbsp;Moves,&nbsp;Script&nbsp;It”（英文）这篇文章中曾谈到，如何使用“Windows&nbsp;Script&nbsp;Host(WSH)”(&nbsp;Windows&nbsp;脚本主机)&nbsp;管理&nbsp;Windows&nbsp;和&nbsp;Windows&nbsp;中的应用程序。文中的大多数示例都是基于管理&nbsp;Windows&nbsp;操作系统自身的，并不基于在该操作系统下运行的应用程序。为迎接新千年，我想我应该谈谈，如何在众多显露可脚本化接口的应用程序中使用脚本。这次只涉及“SQL&nbsp;Server”。在以后的几个月中，我将着重谈&nbsp;Exchange、Office&nbsp;和“系统管理服务器”。</P>
<P><BR>--------------------------------------------------------------------------------<BR>您可以通过使用“分布式管理对象”、“数据转换服务”和新的“SQL&nbsp;Server&nbsp;XML”实现，将脚本用于“SQL&nbsp;Server”。<BR>--------------------------------------------------------------------------------</P>
<P>许多人都能够通过“Active&nbsp;Data&nbsp;Object(ADO)”和“Active&nbsp;Server&nbsp;Page&nbsp;(ASP)”技术访问数据库了。ADO&nbsp;在帮助您查询和更新数据库方面做了大量的工作&nbsp;―&nbsp;但在备份（Y2K&nbsp;问题带给我们的警惕）或是数据库之间的传输数据方面，其表现又如何呢？而这时就非涉及到&nbsp;XML&nbsp;不可了。</P>
<P>在此，我将告诉您如何通过使用&nbsp;ADO&nbsp;的伴随技术&nbsp;－&nbsp;特别是“分布式管理对象”、“数据转换服务”和新的“SQL&nbsp;Server&nbsp;XML”实现，将脚本用于“SQL&nbsp;Server”。</P>
<P>分布式管理对象<BR>“分布式管理对象&nbsp;(DMO)”是一组&nbsp;COM&nbsp;对象，它将“SQL&nbsp;Server”数据库和复制管理封装在一起。这意味着您可以编写一个&nbsp;WSH&nbsp;脚本，将特定表中的所有数据都复制到用制表符分隔的文件中，这有助于大量数据的移动。我之所以选择这个示例，是因为它的代码编写起来简单，但&nbsp;DMO&nbsp;允许您获取“SQL&nbsp;Server”中的每个对象，使您能够编写出一些非常优秀而有意义的管理脚本。</P>
<P>DMO&nbsp;的关键是&nbsp;SQLDMO.SQLServer&nbsp;对象，它是基本的对象，它允许您连接到服务器并获取所有可用对象。在这种情况下，我将使用&nbsp;Database&nbsp;集合来选择数据库，然后从&nbsp;table&nbsp;集合访问要转储到文件的表。如果不提供数据库，将出现错误消息，并且脚本也就结束了。如果不提供表名，脚本将在数据库所有的表中循环，并导出非系统表。如果提供了数据库，它就导出该表。该示例虽然功能有限，但它为“SQL&nbsp;Server”提供了基于命令行的简单的导出实用程序，您可以以它为根据。</P>
<P>现在先看一段代码：</P>
<P>'声明与&nbsp;sql&nbsp;谈话时使用的变量<BR>Dim&nbsp;oServer&nbsp;'&nbsp;SQL&nbsp;Server&nbsp;对象<BR>Dim&nbsp;oDatabase&nbsp;'&nbsp;要使用的目标数据库<BR>Dim&nbsp;oBCP&nbsp;'&nbsp;BCP&nbsp;对象<BR>Dim&nbsp;nRows&nbsp;'&nbsp;从&nbsp;bcp&nbsp;返回的行数<BR>dim&nbsp;table&nbsp;'&nbsp;表对象<BR>on&nbsp;error&nbsp;resume&nbsp;next<BR>'&nbsp;第一个参数必须是数据库<BR>if&nbsp;WScript.Arguments(0)&nbsp;=&nbsp;""&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;WScript.Echo&nbsp;"您没有提供要连接的数据库"<BR>&nbsp;&nbsp;&nbsp;&nbsp;WScript.Quit<BR>end&nbsp;if<BR>'&nbsp;创建&nbsp;SQL&nbsp;DMO&nbsp;的实例<BR>Set&nbsp;oServer&nbsp;=&nbsp;CreateObject("SQLDMO.SQLServer")<BR>'&nbsp;创建&nbsp;SQL&nbsp;DMO&nbsp;Bulkcopy&nbsp;对象的实例<BR>Set&nbsp;oBCP&nbsp;=&nbsp;CreateObject("SQLDMO.BulkCopy")<BR>oServer.EnableBcp&nbsp;=&nbsp;True<BR>'&nbsp;登录到本地服务器<BR>'&nbsp;希望您已经更改了&nbsp;sa&nbsp;口令!!<BR>oServer.Connect&nbsp;".",&nbsp;"sa"&nbsp;<BR>'&nbsp;连接到提供的数据库<BR>Set&nbsp;oDatabase&nbsp;=&nbsp;oServer.Databases(Wscript.Arguments(0))</P>
<P>'&nbsp;将分隔符设置为逗号<BR>oBCP.ColumnDelimiter&nbsp;=&nbsp;vbComma<BR>'&nbsp;将文件类型设置为以逗号分隔<BR>oBCP.DataFileType&nbsp;=&nbsp;SQLDMODataFile_CommaDelimitedChar<BR>oBCP.ImportRowsPerBatch&nbsp;=&nbsp;1000<BR>oBCP.MaximumErrorsBeforeAbort&nbsp;=&nbsp;1<BR>BCP.RowDelimiter&nbsp;=&nbsp;vbCrLf<BR>oBCP.ServerBCPDataFileType&nbsp;=&nbsp;SQLDMOBCPDataFile_Char<BR>oBCP.UseExistingConnection&nbsp;=&nbsp;True<BR>'&nbsp;如果未提供表，则转储所有的表<BR>f&nbsp;wscript.Arguments(1)&nbsp;=&nbsp;""&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;each&nbsp;table&nbsp;in&nbsp;oDatabase.tables<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;确保该表不是系统表<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;table.systemobject&nbsp;=&nbsp;false&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oBCP.DataFilePath&nbsp;=&nbsp;table.name&nbsp;&amp;&nbsp;".csv"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nRows&nbsp;=&nbsp;table.ExportData(oBCP)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wscript.Echo&nbsp;nRows&nbsp;&amp;&nbsp;"&nbsp;rows&nbsp;exported&nbsp;from&nbsp;"&nbsp;&amp;&nbsp;table.name<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;if<BR>&nbsp;&nbsp;&nbsp;&nbsp;next<BR>else<BR>&nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;设置输出文件<BR>&nbsp;&nbsp;&nbsp;&nbsp;oBCP.DataFilePath&nbsp;=&nbsp;wscript.Arguments(1)&nbsp;&amp;&nbsp;".csv"&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;nRows&nbsp;=&nbsp;oDatabase.Tables(wscript.arguments(1)).ExportData(oBCP)<BR>&nbsp;&nbsp;&nbsp;&nbsp;wscript.Echo&nbsp;nRows&nbsp;&amp;&nbsp;"&nbsp;rows&nbsp;exported&nbsp;from&nbsp;"&nbsp;&amp;&nbsp;wscript.arguments(1)<BR>end&nbsp;if<BR>DMO&nbsp;的全部内容要比本文介绍的多得多，但我希望本文能给您一些感性认识：用某些简单的&nbsp;WSH&nbsp;脚本和&nbsp;DMO&nbsp;可以做些什么。您可以下载我的示例（英文）。有关&nbsp;DMO&nbsp;的详细信息，请访问&nbsp;<IMG 
src="http://www.pigtwo.com/forum/pic/url.gif" align=absMiddle border=0><A 
href="http://msdn.microsoft.com/library/psdk/sql/9_dmoc01.htm" 
target=_blank>http://msdn.microsoft.com/library/psdk/sql/9_dmoc01.htm</A>（英文）。&nbsp;</P>
<P>数据转换服务<BR>导出到&nbsp;Comma&nbsp;Separated&nbsp;文件&nbsp;(CSV)，可以作为将数据导出到&nbsp;SQL&nbsp;和从&nbsp;SQL&nbsp;导入的起点，但这不象是尖端科技（太过于&nbsp;20&nbsp;世纪了，您不觉得吗?）。“SQL&nbsp;Server&nbsp;7.0”以“数据转换服务&nbsp;(DTS)”的形式，提供了相当完善的导入和导出机制。幸运的是，脚本在“SQL&nbsp;Server”的这个新领域中仍有一席之地，因此，您可以用“Visual&nbsp;Basic(R)&nbsp;脚本编辑&nbsp;(VBScript)”、“JScript(R)”或“Perl”的技术来扩展&nbsp;DTS&nbsp;的能力。</P>
<P>DTS&nbsp;的设置非常简单，特别是在使用“SQL&nbsp;ServerEnterprise&nbsp;Manager”的时候。在默认情况下，“SQL&nbsp;Server”有一个定义的文件夹，可存储任何转换，而且“Enterprise&nbsp;Manager”提供了创建和编辑&nbsp;DTS&nbsp;程序包的大的图形用户界面&nbsp;(GUI)。在下面的示例中，我选择了已由&nbsp;sqlexport.wsf&nbsp;文件创建的&nbsp;employees.csv&nbsp;文件和“SQL&nbsp;Server”中的一个新表。DTA&nbsp;程序包将创建该表，加载到&nbsp;Text&nbsp;文件中，然后运行某个脚本，将数据转换到“SQL&nbsp;Server”的表中。</P>
<P></P>
<P>DTS&nbsp;程序包中的转换，使脚本在整个转换过程中保持运行状态。“SQL&nbsp;Enterprise&nbsp;Manager”提供的简单的脚本编辑器，有一个语法分析脚本按钮。在运行脚本之前，该按钮将警告您脚本中的错误。在转换过程中，该脚本使用&nbsp;VBScript&nbsp;的&nbsp;Cint&nbsp;功能，将&nbsp;employeeid&nbsp;和&nbsp;deptid&nbsp;的输入转换为&nbsp;int，并将所有的电子邮件地址转换为小写字母。</P>
<P>'**********************************************************************<BR>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visual&nbsp;Basic&nbsp;转换脚本<BR>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把每个源列复制到<BR>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目标列<BR>'***********************************************************************<BR>Function&nbsp;Main()<BR>&nbsp;&nbsp;&nbsp;&nbsp;DTSDestination("EmployeeID")&nbsp;=&nbsp;cint(DTSSource("Col001"))<BR>&nbsp;&nbsp;&nbsp;&nbsp;DTSDestination("FirstName")&nbsp;=&nbsp;DTSSource("Col002")<BR>&nbsp;&nbsp;&nbsp;&nbsp;DTSDestination("LastName")&nbsp;=&nbsp;DTSSource("Col003")<BR>&nbsp;&nbsp;&nbsp;&nbsp;DTSDestination("email")&nbsp;=&nbsp;lcase(DTSSource("Col004"))<BR>&nbsp;&nbsp;&nbsp;&nbsp;DTSDestination("extension")&nbsp;=&nbsp;DTSSource("Col005")<BR>&nbsp;&nbsp;&nbsp;&nbsp;DTSDestination("office")&nbsp;=&nbsp;DTSSource("Col006")<BR>&nbsp;&nbsp;&nbsp;&nbsp;DTSDestination("DeptID")&nbsp;=&nbsp;cint(DTSSource("Col007"))<BR>&nbsp;&nbsp;&nbsp;&nbsp;Main&nbsp;=&nbsp;DTSTransformStat_OK<BR>End&nbsp;Function<BR>用&nbsp;DTS，能够采用某些完善的导入/导出机制，并使您能够在转换的任何一步中使用脚本。重要的是，要注意脚本可能不是操作数据的最佳方式&nbsp;―&nbsp;尤其是您的数据集很大的话。如果您有大量数据需要转换，而且性能也很重要，则您可能需要考虑使用&nbsp;Visual&nbsp;Basic&nbsp;或&nbsp;C++&nbsp;来创建&nbsp;COM&nbsp;组件，然后从&nbsp;DTS&nbsp;内部调用该组件。也就是说，如果性能并不重要，并且要在数据导入/导出时对它进行转换，则脚本为您提供了实现这一点的灵活机制，并使您能够将所有代码存储到“SQL&nbsp;Server”数据库中，使部署变得相当简单。</P>
<P>关于&nbsp;XML<BR>目前，XML&nbsp;看起来像是在应用程序之间共享数据的最佳工具，所以“SQL&nbsp;Server”的所有管理肯定都得到了&nbsp;XML&nbsp;的好处。编写提取数据库中所有数据的脚本，以及编写用编程的方法创建&nbsp;XML&nbsp;文档的脚本，都是可能的。但是，如果您只要查询“SQL&nbsp;Server”的话，最好使它在&nbsp;XML&nbsp;中返回数据，然后用脚本操作该&nbsp;XML。“SQL&nbsp;Server”组最近发行了“SQL&nbsp;Server&nbsp;XML”技术的非正式版本，完全做到了这一点。</P>
<P>新的&nbsp;XML&nbsp;技术使用起来非常简单。实际上是对服务器发出&nbsp;HTTP&nbsp;请求，将查询传递给服务器，而服务器返回&nbsp;XML。为了举例说明，我创建了简单的&nbsp;WSH&nbsp;脚本，它向本地机器查询&nbsp;North&nbsp;Wind&nbsp;数据库的雇员表中的所有数据。为访问&nbsp;XML，该脚本使用了“Internet&nbsp;Explorer&nbsp;5.01”附带的&nbsp;XML&nbsp;分析程序。此对象的美妙之处，在于它处理您所有的&nbsp;HTTP&nbsp;请求，并使您能够同步调用。因为您再也不用处理任何事件驱动的程序，所以，它对编写脚本很有帮助。</P>
<P>该脚本非常简单。它创建了&nbsp;XML&nbsp;分析程序的实例，使用分析程序打开&nbsp;URL，然后将结果保存为&nbsp;.xml&nbsp;文件。只需五行的脚本，不错吧!</P>
<P>'&nbsp;设置请求的&nbsp;url&nbsp;<BR>xmlpath&nbsp;=&nbsp;"<IMG src="http://www.pigtwo.com/forum/pic/url.gif" 
align=absMiddle border=0><A href="http://localhost/Northwind?sql=select+" 
target=_blank>http://localhost/Northwind?sql=select+</A>*+from+employees+for+xml+auto"<BR>'&nbsp;创建“XML&nbsp;分析程序”的实例&nbsp;<BR>Set&nbsp;myXMLDoc&nbsp;=&nbsp;CreateObject("Microsoft.XMLDOM")&nbsp;<BR>'&nbsp;不需要异步&nbsp;<BR>myXMLDoc.async&nbsp;=&nbsp;false&nbsp;<BR>'&nbsp;加载该&nbsp;URL&nbsp;<BR>myXMLDoc.Load&nbsp;xmlpath&nbsp;<BR>'&nbsp;保存文档&nbsp;<BR>myXMLDoc.save&nbsp;"employees.xml"<BR>它的强大之处在于，现在可很容易地与服务器建立远程连接并转储数据；只要更改&nbsp;URL，您早已做过了。此例告诉您如何导出，但是您可以轻松地写出导入例行程序，用&nbsp;XML&nbsp;分析程序在&nbsp;XML&nbsp;中反复操作并将值插入数据库中。</P>
<P>摘要<BR>“SQL&nbsp;Server”提供全面的可编写脚本的机制，用于本地或远程管理数据库。DMO&nbsp;和&nbsp;DTS&nbsp;已经上市（实际上，DMO&nbsp;已发行了许多版本），所以您可以直接利用它们，使您的数据库管理任务自动化。Windows&nbsp;2000&nbsp;已与“Windows&nbsp;Script&nbsp;Host&nbsp;2.0”一起上市，所以以上所有脚本的运行，都不受装有“SQL&nbsp;Server”的&nbsp;Windows&nbsp;2000&nbsp;服务器的条件限制。“SQL&nbsp;Server”中新的&nbsp;XML&nbsp;技术使存取数据变得轻而易举，从而使编写“SQL&nbsp;Server”的脚本更加容易。有关“SQL&nbsp;Server”的详细信息，请访问&nbsp;SQL&nbsp;Server&nbsp;Developer&nbsp;enter（英文）。<BR></P></FONT>