<meta http-equiv="content-type" content="text/html; charset=gb2312"><FONT 
style="FONT-SIZE: 9pt; LINE-HEIGHT: 15pt"><B>存储过程重新编译的疑难解答(二)--MS(ghost)</B><BR>由于交错执行数据定义语句&nbsp;(DDL)&nbsp;和数据操作语句&nbsp;(DML)&nbsp;操作引起重新编译&nbsp;
<P></P>
<P><BR>如果&nbsp;DDL&nbsp;操作是在一个过程或批处理内执行的，则过程或批处理在遇到随之发生的影响&nbsp;DDL&nbsp;中涉及的表的第一个&nbsp;DML&nbsp;操作时将进行重新编译。&nbsp;</P>
<P>请考虑下列示例存储过程：&nbsp;<BR>drop&nbsp;procedure&nbsp;Interleave&nbsp;gocreate&nbsp;procedure&nbsp;Interleave&nbsp;as--&nbsp;DDLcreate&nbsp;table&nbsp;#t1&nbsp;(a&nbsp;int)--&nbsp;DMLselect&nbsp;*&nbsp;from&nbsp;#t1--&nbsp;DDLcreate&nbsp;index&nbsp;idx_#t1&nbsp;on&nbsp;#t1(a)--&nbsp;DMLselect&nbsp;*&nbsp;from&nbsp;#t1--&nbsp;DDLcreate&nbsp;table&nbsp;#t2&nbsp;(a&nbsp;int)--&nbsp;DMLselect&nbsp;*&nbsp;from&nbsp;#t2goexec&nbsp;Interleave<BR>如果在&nbsp;Query&nbsp;Analyzer&nbsp;中执行该代码并在“事件探查器”跟踪中查看上述事件，将看到下列序列：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;Interleave&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t1&nbsp;(a&nbsp;int)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;Interleave&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;index&nbsp;idx_#t1&nbsp;on&nbsp;#t1(a)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;Interleave&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t2&nbsp;(a&nbsp;int)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t2&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;Interleave&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t2&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;Interleave&nbsp;&nbsp;</P>
<P><BR>在这种情况下，存储过程在执行期间重新编译三次。&nbsp;要了解发生这种情况的原因，请考虑优化器为存储过程开发计划的方式：&nbsp;<BR>在过程的初始编译过程中，并不存在临时表&nbsp;#t1&nbsp;和&nbsp;#t2。&nbsp;因此，没有创建引用这些表的查询的计划。&nbsp;这些计划必须是在执行期间生成的。&nbsp;<BR>在过程第一次执行时，第一步是创建表&nbsp;#t1。&nbsp;第二步是从表&nbsp;#t1&nbsp;中进行选择，该选择还没有计划。&nbsp;因此，此时重新编译过程来为&nbsp;SELECT&nbsp;语句生成计划。&nbsp;为表&nbsp;#t1&nbsp;中的当前选择生成计划，也为创建索引后表&nbsp;#t1&nbsp;中的选择生成计划。&nbsp;没有为表&nbsp;#t2&nbsp;中的选择生成计划，因为表&nbsp;#t2&nbsp;还不存在。&nbsp;<BR>下一步是对表&nbsp;#t1&nbsp;创建索引。&nbsp;随后，在表&nbsp;#t1&nbsp;上执行另一个选择，现在它有来自第一次重新编译的一个计划。&nbsp;但是，因为表&nbsp;#t1&nbsp;的架构自从生成计划后已更改，因此必须再次重新编译过程来为表&nbsp;#t1&nbsp;中的选择生成新计划。&nbsp;由于表&nbsp;#t2&nbsp;还不存在，还不可以为表&nbsp;#t2&nbsp;中的选择生成计划。&nbsp;<BR>下一步，创建表&nbsp;#t2，并执行表&nbsp;#t2&nbsp;中的选择。&nbsp;由于没有用于该语句的计划，最终一次重新编译过程。&nbsp;<BR>在每次执行存储过程时都发生这些重新编译。&nbsp;要减少重新编译的次数，请将过程修改为先执行所有&nbsp;DDL&nbsp;操作，然后接着执行&nbsp;DML&nbsp;操作，如下所示：&nbsp;</P>
<P>drop&nbsp;procedure&nbsp;NoInterleave&nbsp;gocreate&nbsp;procedure&nbsp;NoInterleave&nbsp;as--&nbsp;All&nbsp;DDL&nbsp;firstcreate&nbsp;table&nbsp;#t1&nbsp;(a&nbsp;int)create&nbsp;index&nbsp;idx_#t1&nbsp;on&nbsp;#t1(a)create&nbsp;table&nbsp;#t2&nbsp;(a&nbsp;int)--&nbsp;Then&nbsp;DML&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1select&nbsp;*&nbsp;from&nbsp;#t1select&nbsp;*&nbsp;from&nbsp;#t2goexec&nbsp;NoInterleave&nbsp;exec&nbsp;NoInterleave<BR>NoInterleave&nbsp;过程的第一次执行将在“事件探查器”中显示下列事件：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;NoInterleave&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t1&nbsp;(a&nbsp;int)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;index&nbsp;idx_#t1&nbsp;on&nbsp;#t1(a)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t2&nbsp;(a&nbsp;int)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;NoInterleave&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;#t2&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;NoInterleave&nbsp;&nbsp;</P>
<P><BR>在这种情况下，所有&nbsp;DDL&nbsp;语句是先完成的。&nbsp;优化器如下编译该过程：&nbsp;<BR>在过程的初始编译过程中，并不存在临时表&nbsp;#t1&nbsp;和&nbsp;#t2。&nbsp;因此，没有创建引用这些表的查询的计划。&nbsp;这些计划必须是在执行期间生成的。&nbsp;<BR>过程执行的第一个步骤是&nbsp;DDL&nbsp;操作，创建表&nbsp;#t1&nbsp;和&nbsp;#t2，及表&nbsp;#t1&nbsp;上的索引。&nbsp;<BR>下一步是从表&nbsp;#t1&nbsp;中进行第一次选择。&nbsp;由于该&nbsp;SELECT&nbsp;语句没有可用计划，将重新编译过程。&nbsp;由于所有对象均存在，此时将为过程中的所有&nbsp;SELECT&nbsp;语句生成计划。&nbsp;<BR>使用生成的计划执行过程的剩余部分。&nbsp;由于没有对引用对象进行更改，因此无须进一步重新编译过程。&nbsp;<BR>备注：&nbsp;第二次执行和后续执行将利用现有查询计划和高速缓存，而且根本不会引起重新编译。&nbsp;频繁使用临时表的过程应加以修改，以确保所有&nbsp;DDL&nbsp;语句均在该过程的开始部分。&nbsp;<BR>由于某些临时表操作引起的重新编译&nbsp;</P>
<P><BR>在存储过程中使用临时表可能会导致在每次执行过程时重新编译存储过程。&nbsp;</P>
<P>为避免这种情况，请更改存储过程以符合下列要求：&nbsp;<BR>所有包含临时表名称的语句都引用在同一存储过程创建的临时表，而不是在正在调用或已调用的存储过程中创建的临时表，或在&nbsp;EXECUTE&nbsp;语句所执行的字符串或&nbsp;sp_executesql&nbsp;存储过程中创建的临时表。&nbsp;<BR>包含临时表名称的所有语句句法上出现在存储过程或触发器中临时表的执行&nbsp;SELECT&nbsp;语句。&nbsp;<BR>没有其&nbsp;SELECT&nbsp;语句引用临时表的&nbsp;DECLARE&nbsp;CURSOR&nbsp;语句。&nbsp;<BR>包含任意临时表名称的所有语句出现在引用临时表的任何&nbsp;DROP&nbsp;TABLE&nbsp;语句之前。&nbsp;</P>
<P>在存储过程中创建的临时表不需要&nbsp;DROP&nbsp;TABLE&nbsp;语句。&nbsp;在过程执行完毕时，这些表自动消失。&nbsp;<BR>创建临时表（如&nbsp;CREATE&nbsp;TABLE&nbsp;或&nbsp;SELECT...&nbsp;INTO）的语句不出现在流控制语句如&nbsp;IF...&nbsp;ELSE&nbsp;或&nbsp;WHILE&nbsp;中。&nbsp;<BR>使用&nbsp;KEEP&nbsp;PLAN&nbsp;选项避免重新编译&nbsp;</P>
<P><BR>在存储过程中使用临时表使得查询优化程序变得有些复杂。&nbsp;表的行计数和统计信息在存储过程执行的整个期间变化非常大。&nbsp;为确保优化器在所有涉及临时表的情况下使用最优计划，已开发了一种特殊算法，该算法对于重新编译更具有主动性。&nbsp;该算法的原理是：如果对存储过程创建的临时表已更改六次以上，将在下一个语句引用临时表时重新编译过程。&nbsp;</P>
<P>请考虑下列示例：&nbsp;<BR>drop&nbsp;procedure&nbsp;useKeepPlan&nbsp;gocreate&nbsp;procedure&nbsp;useKeepPlan&nbsp;ascreate&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int,&nbsp;b&nbsp;char(3))select&nbsp;*&nbsp;from&nbsp;#t--&nbsp;Make&nbsp;greater&nbsp;than&nbsp;6&nbsp;changes&nbsp;to&nbsp;#tinsert&nbsp;#t&nbsp;values&nbsp;(1,&nbsp;'abc')insert&nbsp;#t&nbsp;values&nbsp;(2,&nbsp;'abc')insert&nbsp;#t&nbsp;values&nbsp;(3,&nbsp;'abc')insert&nbsp;#t&nbsp;values&nbsp;(4,&nbsp;'abc')insert&nbsp;#t&nbsp;values&nbsp;(5,&nbsp;'abc')insert&nbsp;#t&nbsp;values&nbsp;(6,&nbsp;'abc')insert&nbsp;#t&nbsp;values&nbsp;(7,&nbsp;'abc')--&nbsp;Now&nbsp;reference&nbsp;#tselect&nbsp;count(*)&nbsp;from&nbsp;#t&nbsp;--option&nbsp;(KEEP&nbsp;PLAN)goexec&nbsp;useKeepPlanexec&nbsp;useKeepPlan<BR>在这种情况下，第二次执行时在“事件查看器”中将看到下列事件：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;useKeepPlan&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;-&nbsp;The&nbsp;seven&nbsp;insert&nbsp;statements&nbsp;-&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:Recompile&nbsp;&nbsp;useKeepPlan&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t1&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;useKeepPlan&nbsp;&nbsp;</P>
<P>对临时表&nbsp;#t&nbsp;进行第七次更改之后，当进行选择时将重新编译过程。&nbsp;</P>
<P>当对临时表数据分布进行更改会极大地影响引用它的语句的最优查询计划时，主动进行重新编译是非常有帮助的。&nbsp;不过，在频繁修改临时表的大型过程的情况下，但并不到值得注意的程度，重新编译将导致整体性能更低。&nbsp;在这种情况下引入&nbsp;SELECT&nbsp;语句的&nbsp;KEEP&nbsp;PLAN&nbsp;选项。&nbsp;</P>
<P>KEEP&nbsp;PLAN&nbsp;消除了由于过程中有六次以上的临时表更改而引发的存储过程重新编译，并还原回标准算法，有关由于行修改而导致重新编译的内容在本文上述“由于行修改导致重新编译”部分给予讨论。&nbsp;总而言之，KEEP&nbsp;PLAN&nbsp;不会阻止重新编译，它只是阻止由于在过程中对引用表的更改超过六次而引发的那些重新编译。&nbsp;在上述示例中，如果在存储过程的“option&nbsp;(KEEP&nbsp;PLAN)”行删除注释，将不会生成&nbsp;SP:Recompile。&nbsp;</P>
<P>如果从上述代码的“option&nbsp;(KEEP&nbsp;PLAN)”行删除注释并执行它，将在“事件探查器”中将看到下列事件：&nbsp;</P>
<P>SP:Starting&nbsp;&nbsp;useKeepPlan&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;create&nbsp;table&nbsp;#t&nbsp;(a&nbsp;int)&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;-&nbsp;The&nbsp;seven&nbsp;insert&nbsp;statements&nbsp;-&nbsp;&nbsp;<BR>SP:StmtStarting&nbsp;&nbsp;select&nbsp;count(*)&nbsp;from&nbsp;#t1&nbsp;option&nbsp;(KEEP&nbsp;PLAN)&nbsp;&nbsp;<BR>SP:Completed&nbsp;&nbsp;useKeepPlan&nbsp;&nbsp;</P>
<P><BR>注意没有&nbsp;SP:Recompile&nbsp;事件。</P></FONT>