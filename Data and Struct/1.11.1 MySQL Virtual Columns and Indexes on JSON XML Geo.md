## Catalog 目录
* [Creating Virutal Columns](#Creating_Virutal_Columns)
* [Creating Indexes on Non-Materialized Virtual Columns](#Creating_Indexes_on_NonMaterialized_Virtual_Columns)
* [Query Using A Funcional Index With JSON/XML/Geo/String](#Query_Using_A_Funcional_Index_With_JSON_XML_Geo_String)
* [Quick Performance Benchmarks](#Quick_Performance_Benchmarks)


Reference:
* http://mysqlserverteam.com/virtual-columns-and-effective-functional-indexes-in-innodb/
* https://dev.mysql.com/doc/refman/5.7/en/innodb-sys-columns-table.html
* https://dev.mysql.com/doc/refman/5.7/en/innodb-sys-virtual-table.html


# Creating Virutal Columns <a id="Creating_Virutal_Columns"></a>

## Summary
* The virtual columns are no longer materialized in the table. They are truly “virtual”, which means they are NOT stored in InnoDB rows (InnoDB stores the table data in its primary key records—a clustered index—so it means that virtual columns will not be present in InnoDB primary key records), thus decreasing the overall size of the table. This then allows for faster table scans and other large operations.
* Since they are truly “virtual”, adding and dropping virtual columns does not require a table rebuild. Rather, it only requires a quick system table update that registers the new metadata. This makes the schema changes simple and fast.
* Creating an index on a virtual column (only secondary indexes are allowed) will essentially “materialize” the virtual column in the index records as the computed values are then stored in the secondary index, but the values are not stored in the primary key (clustered index). So the table itself is still small, and you can quickly look up the computed (and stored) virtual column values in the secondary index.
* Once an index is created on a virtual column, the value for such a virtual column is MVCC logged so as to avoid unnecessary re-computation of the generated column value later when we have to perform a rollback or purge operation. However, since its purpose is in maintaining the secondary index only, we will only log only up to a certain limited length of the data in order to save space, since our index has a key length limitation of 767 bytes for COMPACT and REDUNDANT for formats, and 3072 bytes for DYNAMIC and COMPRESSED row formats.
* Primary Keys cannot be added on virtual columns, only Secondary keys can.
* You cannot create a spatial or fulltext index on virtual columns (this limitation will eventually be lifted).
* A virtual index cannot be used as a foreign key.
* You cannot create virtual columns on non-repeatable/non-deterministic functions. e.g. `ALTER TABLE `t` ADD p3 DATE GENERATED ALWAYS AS (curtime()) virtual;` ERROR 3102 (HY000): Expression of generated column 'p3' contains a disallowed function
* Adding and dropping of virtual columns can be done in-place or online only when done as single operations by themselves, and not when combined with other table alterations. This limit will be removed later, but you can always go around it by keeping the in-place ADD/DROP virtual columns operations contained within a separate DDL statement.

## The virtual column is not stored within the InnoDB table
```
db> CREATE TABLE t (a INT, b INT, c INT GENERATED ALWAYS AS(a+b), PRIMARY KEY(a));
db> INSERT INTO t VALUES (11, 3, default);
```
Here, column ‘c’ is a virtual column. If we look at the physical data layout of this table in InnoDB, we can see that it only has 2 user columns—column ‘a’ and column ‘b’—along with the 2 standard InnoDB hidden/internal columns (DATA_TRX_ID and DATA_ROLL_PTR):
```
not-deleted PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 8000000b; asc     ;;           /* column 'a' */
 1: len 6; hex 00000000670b; asc     g ;;     /* InnoDB hidden column */
 2: len 7; hex a90000011d0110; asc        ;;  /* InnoDB hidden column */
 3: len 4; hex 80000003; asc     ;;           /* column 'b' */
```
So the column ‘c’ is not stored within the InnoDB table and rows, but is instead calculated on the fly when you query the table.
```
db> SELECT * FROM t;
    +----+------+------+
    | a  | b    | c   
    +----+------+------+
    | 11 |    3 |   14
    +----+------+------+
```

## The virtual column’s metadata representation
Even though the virtual column itself is no longer stored within InnoDB, its metadata is. 
We need to do that in order to support the creation of secondary indexes on such columns.

### INFORMATION_SCHEMA.INNODB_SYS_TABLES
```
db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES;
+------+---------------------------------+----+----+---+----------+---------+-------+---------
| TABLE|                                 | FL |N_  |SPA| FILE_    | ROW_    | SPACE |ZIP_PAGE
|  _ID | NAME                            | AG |COLS| CE| FORMAT   | FORMAT  | _TYPE | _SIZE
+------+---------------------------------+----+----+---+----------+---------+-------+--------
|  14  | SYS_DATAFILES                   |  0 |  5 |  0| Antelope |Redundant| System| 0  
|  11  | SYS_FOREIGN                     |  0 |  7 |  0| Antelope |Redundant| System| 0  
|  12  | SYS_FOREIGN_COLS                |  0 |  7 |  0| Antelope |Redundant| System| 0  
|  13  | SYS_TABLESPACES                 |  0 |  6 |  0| Antelope |Redundant| System| 0  
|  15  | SYS_VIRTUAL                     |  0 |  6 |  0| Antelope |Redundant| System| 0  
|  46  | aa_tests/t                      | 33 |  6 | 35| Barracuda| Dynamic | Single| 0
|  34  | mysql/engine_cost               | 33 |  9 | 20| Barracuda| Dynamic | Single| 0
|  32  | mysql/gtid_executed             | 33 |  6 | 18| Barracuda| Dynamic | Single| 0
|  36  | mysql/help_category             | 33 |  7 |  5| Barracuda| Dynamic | Single| 0
|  37  | mysql/help_keyword              | 33 |  5 |  7| Barracuda| Dynamic | Single| 0
|  38  | mysql/help_relation             | 33 |  5 |  6| Barracuda| Dynamic | Single| 0
|  35  | mysql/help_topic                | 33 |  9 |  4| Barracuda| Dynamic | Single| 0
|  28  | mysql/innodb_index_stats        | 33 | 11 | 14| Barracuda| Dynamic | Single| 0
|  27  | mysql/innodb_table_stats        | 33 |  9 | 13| Barracuda| Dynamic | Single| 0
|  16  | mysql/plugin                    | 33 |  5 |  2| Barracuda| Dynamic | Single| 0
|  33  | mysql/server_cost               | 33 |  7 | 19| Barracuda| Dynamic | Single| 0
|  17  | mysql/servers                   | 33 | 12 |  3| Barracuda| Dynamic | Single| 0
|  30  | mysql/slave_master_info         | 33 | 28 | 16| Barracuda| Dynamic | Single| 0
|  29  | mysql/slave_relay_log_info      | 33 | 12 | 15| Barracuda| Dynamic | Single| 0
|  31  | mysql/slave_worker_info         | 33 | 16 | 17| Barracuda| Dynamic | Single| 0
|  40  | mysql/time_zone                 | 33 |  5 |  9| Barracuda| Dynamic | Single| 0
|  26  | mysql/time_zone_leap_second     | 33 |  5 | 12| Barracuda| Dynamic | Single| 0
|  41  | mysql/time_zone_name            | 33 |  5 |  8| Barracuda| Dynamic | Single| 0
|  42  | mysql/time_zone_transition      | 33 |  6 | 10| Barracuda| Dynamic | Single| 0
|  43  | mysql/time_zone_transition_type | 33 |  8 | 11| Barracuda| Dynamic | Single| 0
|  39  | sys/sys_config                  | 33 |  7 | 21| Barracuda| Dynamic | Single| 0
+------+---------------------------------+----+----+---+----------+---------+-------+----

db> SHOW CREATE TABLE aa_tests.t \G
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE `t` (
  `a` int(11) NOT NULL,
  `b` int(11) DEFAULT NULL,
  `c` int(11) GENERATED ALWAYS AS ((`a` + `b`)) VIRTUAL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

```

### INFORMATION_SCHEMA.INNODB_SYS_COLUMNS
* TABLE_ID: An identifier representing the table associated with the column; the same value from INNODB_SYS_TABLES.TABLE_ID.
* NAME: These names can be uppercase or lowercase depending on the lower_case_table_names setting. There are no special system-reserved names for columns.
* POS: The ordinal position of the column within the table, starting from 0 and incrementing sequentially. When a column is dropped, the remaining columns are reordered so that the sequence has no gaps. The POS value for a virtual generated column encodes the column sequence number and ordinal position of the column. The formula used to calculate the value uses a bitwise operation. The formula is `((nth virtual generated column for the InnoDB instance + 1) << 16) + the ordinal position of the generated virtual column`. For example, if the first virtual generated column in the InnoDB instance is the third column of the table, the formula is `(0 + 1) << 16) + 2`. The first generated virtual column in the InnoDB instance is always number 0. As the third column in the table, the ordinal position of the generated virtual column is 2. Ordinal positions are counted from 0.
* MTYPE: Stands for “main type”. A numeric identifier for the column type.  This field is described in the storage/innobase/include/data0type.h source file.

```c
#define DATA_MISSING	0	/* missing column */
#define	DATA_VARCHAR	1	/* character varying of the
				latin1_swedish_ci charset-collation; note
				that the MySQL format for this, DATA_BINARY,
				DATA_VARMYSQL, is also affected by whether the
				'precise type' contains
				DATA_MYSQL_TRUE_VARCHAR */
#define DATA_CHAR	2	/* fixed length character of the
				latin1_swedish_ci charset-collation */
#define DATA_FIXBINARY	3	/* binary string of fixed length */
#define DATA_BINARY	4	/* binary string */
#define DATA_BLOB	5	/* binary large object, or a TEXT type;
				if prtype & DATA_BINARY_TYPE == 0, then this is
				actually a TEXT column (or a BLOB created
				with < 4.0.14; since column prefix indexes
				came only in 4.0.14, the missing flag in BLOBs
				created before that does not cause any harm) */
#define	DATA_INT	6	/* integer: can be any size 1 - 8 bytes */
#define	DATA_SYS_CHILD	7	/* address of the child page in node pointer */
#define	DATA_SYS	8	/* system column */

/* Data types >= DATA_FLOAT must be compared using the whole field, not as
binary strings */

#define DATA_FLOAT	9
#define DATA_DOUBLE	10
#define DATA_DECIMAL	11	/* decimal number stored as an ASCII string */
#define	DATA_VARMYSQL	12	/* any charset varying length char */
#define	DATA_MYSQL	13	/* any charset fixed length char */
				/* NOTE that 4.1.1 used DATA_MYSQL and
				DATA_VARMYSQL for all character sets, and the
				charset-collation for tables created with it
				can also be latin1_swedish_ci */

/* DATA_POINT&DATA_VAR_POINT are for standard geometry datatype 'point' and
DATA_GEOMETRY include all other standard geometry datatypes as described in
OGC standard(line_string, polygon, multi_point, multi_polygon,
multi_line_string, geometry_collection, geometry).
Currently, geometry data is stored in the standard Well-Known Binary(WKB)
format (http://www.opengeospatial.org/standards/sfa).
We use BLOB as underlying datatype for DATA_GEOMETRY and DATA_VAR_POINT
while CHAR for DATA_POINT */
#define DATA_GEOMETRY	14	/* geometry datatype of variable length */
/* The following two are disabled temporarily, we won't create them in
get_innobase_type_from_mysql_type().
TODO: We will enable DATA_POINT/them when we come to the fixed-length POINT
again. */
#define DATA_POINT	15	/* geometry datatype of fixed length POINT */
#define DATA_VAR_POINT	16	/* geometry datatype of variable length
				POINT, used when we want to store POINT
				as BLOB internally */
#define DATA_MTYPE_MAX	63	/* dtype_store_for_order_and_null_size()
				requires the values are <= 63 */
```
* PRTYPE: The InnoDB “precise type”, a binary value with bits representing MySQL data type, character set code, and nullability.  This field includes information such as the column data type, character set code, nullability, signedness, and whether it is a binary string. This field is described in the storage/innobase/include/data0type.h source file.
```c
#define DATA_ENGLISH	4	/* English language character string: this
				is a relic from pre-MySQL time and only used
				for InnoDB's own system tables */
#define DATA_ERROR	111	/* another relic from pre-MySQL time */

#define DATA_MYSQL_TYPE_MASK 255 /* AND with this mask to extract the MySQL
				 type from the precise type */
#define DATA_MYSQL_TRUE_VARCHAR 15 /* MySQL type code for the >= 5.0.3
				   format true VARCHAR */

/* Precise data types for system columns and the length of those columns;
NOTE: the values must run from 0 up in the order given! All codes must
be less than 256 */
#define	DATA_ROW_ID	0	/* row id: a 48-bit integer */
#define DATA_ROW_ID_LEN	6	/* stored length for row id */

#define DATA_TRX_ID	1	/* transaction id: 6 bytes */
#define DATA_TRX_ID_LEN	6

#define	DATA_ROLL_PTR	2	/* rollback data pointer: 7 bytes */
#define DATA_ROLL_PTR_LEN 7

#define	DATA_N_SYS_COLS 3	/* number of system columns defined above */

#define	DATA_ITT_N_SYS_COLS	2
				/* number of system columns for intrinsic
				temporary table */

#define DATA_FTS_DOC_ID	3	/* Used as FTS DOC ID column */

#define DATA_SYS_PRTYPE_MASK 0xF /* mask to extract the above from prtype */

/* Flags ORed to the precise data type */
#define DATA_NOT_NULL	256	/* this is ORed to the precise type when
				the column is declared as NOT NULL */
#define DATA_UNSIGNED	512	/* this id ORed to the precise type when
				we have an unsigned integer type */
#define	DATA_BINARY_TYPE 1024	/* if the data type is a binary character
				string, this is ORed to the precise type:
				this only holds for tables created with
				>= MySQL-4.0.14 */
/* #define	DATA_NONLATIN1	2048 This is a relic from < 4.1.2 and < 5.0.1.
				In earlier versions this was set for some
				BLOB columns.
*/
#define DATA_GIS_MBR	2048	/* Used as GIS MBR column */
#define DATA_MBR_LEN	SPDIMS * 2 * sizeof(double) /* GIS MBR length*/

#define	DATA_LONG_TRUE_VARCHAR 4096	/* this is ORed to the precise data
				type when the column is true VARCHAR where
				MySQL uses 2 bytes to store the data len;
				for shorter VARCHARs MySQL uses only 1 byte */
#define	DATA_VIRTUAL	8192	/* Virtual column */

```
* LEN: The column length
```
db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_COLUMNS;
+----------+----------------------------+-------+-------+----------+------+
| TABLE_ID | NAME                       | POS   | MTYPE | PRTYPE   | LEN 
+----------+----------------------------+-------+-------+----------+------+
|       11 | ID                         |     0 |     1 | 14680068 |    0
|       11 | FOR_NAME                   |     1 |     1 | 14680068 |    0
|       11 | REF_NAME                   |     2 |     1 | 14680068 |    0
|       11 | N_COLS                     |     3 |     6 |        0 |    4
|       12 | ID                         |     0 |     1 | 14680068 |    0
|       12 | POS                        |     1 |     6 |        0 |    4
|       12 | FOR_COL_NAME               |     2 |     1 | 14680068 |    0
|       12 | REF_COL_NAME               |     3 |     1 | 14680068 |    0
|       13 | SPACE                      |     0 |     6 |        0 |    4
|       13 | NAME                       |     1 |     1 | 14680068 |    0
|       13 | FLAGS                      |     2 |     6 |        0 |    4
|       14 | SPACE                      |     0 |     6 |        0 |    4
|       14 | PATH                       |     1 |     1 | 14680068 |    0
|       15 | TABLE_ID                   |     0 |     6 |        0 |    8
|       15 | POS                        |     1 |     6 |        0 |    4
|       15 | BASE_POS                   |     2 |     6 |        0 |    4
|       16 | name                       |     0 |    12 |  2162959 |  192
|       16 | dl                         |     1 |    12 |  2167055 |  384
|       17 | Server_name                |     0 |    13 |  2163198 |  192
|       17 | Host                       |     1 |    13 |  2163198 |  192
|       17 | Db                         |     2 |    13 |  2163198 |  192
|       17 | Username                   |     3 |    13 |  2163198 |  192
|       17 | Password                   |     4 |    13 |  2163198 |  192
|       17 | Port                       |     5 |     6 |     1283 |    4
|       17 | Socket                     |     6 |    13 |  2163198 |  192
|       17 | Wrapper                    |     7 |    13 |  2163198 |  192
|       17 | Owner                      |     8 |    13 |  2163198 |  192
|       26 | Transition_time            |     0 |     6 |     1288 |    8
|       26 | Correction                 |     1 |     6 |     1283 |    4
|       27 | database_name              |     0 |    12 |  5439759 |  192
|       27 | table_name                 |     1 |    12 |  5439759 |  192
|       27 | last_update                |     2 |     3 |   525575 |    4
|       27 | n_rows                     |     3 |     6 |     1800 |    8
|       27 | clustered_index_size       |     4 |     6 |     1800 |    8
|       27 | sum_of_other_index_sizes   |     5 |     6 |     1800 |    8
|       28 | database_name              |     0 |    12 |  5439759 |  192
|       28 | table_name                 |     1 |    12 |  5439759 |  192
|       28 | index_name                 |     2 |    12 |  5439759 |  192
|       28 | last_update                |     3 |     3 |   525575 |    4
|       28 | stat_name                  |     4 |    12 |  5439759 |  192
|       28 | stat_value                 |     5 |     6 |     1800 |    8
|       28 | sample_size                |     6 |     6 |     1544 |    8
|       28 | stat_description           |     7 |    12 |  5443855 | 3072
|       29 | Number_of_lines            |     0 |     6 |     1795 |    4
|       29 | Relay_log_name             |     1 |     5 |  5439996 |   10
|       29 | Relay_log_pos              |     2 |     6 |     1800 |    8
|       29 | Master_log_name            |     3 |     5 |  5439996 |   10
|       29 | Master_log_pos             |     4 |     6 |     1800 |    8
|       29 | Sql_delay                  |     5 |     6 |     1283 |    4
|       29 | Number_of_workers          |     6 |     6 |     1795 |    4
|       29 | Id                         |     7 |     6 |     1795 |    4
|       29 | Channel_name               |     8 |    13 |  2163198 |  192
|       30 | Number_of_lines            |     0 |     6 |     1795 |    4
|       30 | Master_log_name            |     1 |     5 |  5439996 |   10
|       30 | Master_log_pos             |     2 |     6 |     1800 |    8
|       30 | Host                       |     3 |    13 |  5439742 |  192
|       30 | User_name                  |     4 |     5 |  5439740 |   10
|       30 | User_password              |     5 |     5 |  5439740 |   10
|       30 | Port                       |     6 |     6 |     1795 |    4
|       30 | Connect_retry              |     7 |     6 |     1795 |    4
|       30 | Enabled_ssl                |     8 |     6 |     1281 |    1
|       30 | Ssl_ca                     |     9 |     5 |  5439740 |   10
|       30 | Ssl_capath                 |    10 |     5 |  5439740 |   10
|       30 | Ssl_cert                   |    11 |     5 |  5439740 |   10
|       30 | Ssl_cipher                 |    12 |     5 |  5439740 |   10
|       30 | Ssl_key                    |    13 |     5 |  5439740 |   10
|       30 | Ssl_verify_server_cert     |    14 |     6 |     1281 |    1
|       30 | Heartbeat                  |    15 |     9 |     1284 |    4
|       30 | Bind                       |    16 |     5 |  5439740 |   10
|       30 | Ignored_server_ids         |    17 |     5 |  5439740 |   10
|       30 | Uuid                       |    18 |     5 |  5439740 |   10
|       30 | Retry_count                |    19 |     6 |     1800 |    8
|       30 | Ssl_crl                    |    20 |     5 |  5439740 |   10
|       30 | Ssl_crlpath                |    21 |     5 |  5439740 |   10
|       30 | Enabled_auto_position      |    22 |     6 |     1281 |    1
|       30 | Channel_name               |    23 |    13 |  2163198 |  192
|       30 | Tls_version                |    24 |     5 |  5439740 |   10
|       31 | Id                         |     0 |     6 |     1795 |    4
|       31 | Relay_log_name             |     1 |     5 |  5439996 |   10
|       31 | Relay_log_pos              |     2 |     6 |     1800 |    8
|       31 | Master_log_name            |     3 |     5 |  5439996 |   10
|       31 | Master_log_pos             |     4 |     6 |     1800 |    8
|       31 | Checkpoint_relay_log_name  |     5 |     5 |  5439996 |   10
|       31 | Checkpoint_relay_log_pos   |     6 |     6 |     1800 |    8
|       31 | Checkpoint_master_log_name |     7 |     5 |  5439996 |   10
|       31 | Checkpoint_master_log_pos  |     8 |     6 |     1800 |    8
|       31 | Checkpoint_seqno           |     9 |     6 |     1795 |    4
|       31 | Checkpoint_group_size      |    10 |     6 |     1795 |    4
|       31 | Checkpoint_group_bitmap    |    11 |     5 |  4130300 |   10
|       31 | Channel_name               |    12 |    13 |  2163198 |  192
|       32 | source_uuid                |     0 |    13 | 14680574 |  144
|       32 | interval_start             |     1 |     6 |     1288 |    8
|       32 | interval_end               |     2 |     6 |     1288 |    8
|       33 | cost_name                  |     0 |    12 |  2162959 |  192
|       33 | cost_value                 |     1 |     9 |     1028 |    4
|       33 | last_update                |     2 |     3 |   525575 |    4
|       33 | comment                    |     3 |    12 |  2166799 | 3072
|       34 | engine_name                |     0 |    12 |  2162959 |  192
|       34 | device_type                |     1 |     6 |     1283 |    4
|       34 | cost_name                  |     2 |    12 |  2162959 |  192
|       34 | cost_value                 |     3 |     9 |     1028 |    4
|       34 | last_update                |     4 |     3 |   525575 |    4
|       34 | comment                    |     5 |    12 |  2166799 | 3072
|       35 | help_topic_id              |     0 |     6 |     1795 |    4
|       35 | name                       |     1 |    13 |  2163198 |  192
|       35 | help_category_id           |     2 |     6 |     1794 |    2
|       35 | description                |     3 |     5 |  2163196 |   10
|       35 | example                    |     4 |     5 |  2163196 |   10
|       35 | url                        |     5 |     5 |  2163196 |   10
|       36 | help_category_id           |     0 |     6 |     1794 |    2
|       36 | name                       |     1 |    13 |  2163198 |  192
|       36 | parent_category_id         |     2 |     6 |     1538 |    2
|       36 | url                        |     3 |     5 |  2163196 |   10
|       37 | help_keyword_id            |     0 |     6 |     1795 |    4
|       37 | name                       |     1 |    13 |  2163198 |  192
|       38 | help_topic_id              |     0 |     6 |     1795 |    4
|       38 | help_keyword_id            |     1 |     6 |     1795 |    4
|       39 | variable                   |     0 |    12 |  2167055 |  384
|       39 | value                      |     1 |    12 |  2166799 |  384
|       39 | set_time                   |     2 |     3 |   525575 |    4
|       39 | set_by                     |     3 |    12 |  2166799 |  384
|       40 | Time_zone_id               |     0 |     6 |     1795 |    4
|       40 | Use_leap_seconds           |     1 |     6 |     1022 |    1
|       41 | Name                       |     0 |    13 |  2163198 |  192
|       41 | Time_zone_id               |     1 |     6 |     1795 |    4
|       42 | Time_zone_id               |     0 |     6 |     1795 |    4
|       42 | Transition_time            |     1 |     6 |     1288 |    8
|       42 | Transition_type_id         |     2 |     6 |     1795 |    4
|       43 | Time_zone_id               |     0 |     6 |     1795 |    4
|       43 | Transition_type_id         |     1 |     6 |     1795 |    4
|       43 | Offset                     |     2 |     6 |     1283 |    4
|       43 | Is_DST                     |     3 |     6 |     1793 |    1
|       43 | Abbreviation               |     4 |    13 |  2163198 |   24
|       46 | a                          |     0 |     6 |     1283 |    4
|       46 | b                          |     1 |     6 |     1027 |    4
|       46 | c                          | 65538 |     6 |     9219 |    4
+----------+----------------------------+-------+-------+----------+------+


db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_COLUMNS WHERE TABLE_ID = (
        SELECT TABLE_ID FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME = 'aa_tests/t' LIMIT 1
    );
+----------+------+-------+-------+--------+-----+
| TABLE_ID | NAME | POS   | MTYPE | PRTYPE | LEN
+----------+------+-------+-------+--------+-----+
|       46 | a    |     0 |     6 |   1283 |   4
|       46 | b    |     1 |     6 |   1027 |   4
|       46 | c    | 65538 |     6 |   9219 |   4
+----------+------+-------+-------+--------+-----+

db> SHOW CREATE TABLE aa_tests.t \G
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE `t` (
  `a` int(11) NOT NULL,
  `b` int(11) DEFAULT NULL,
  `c` int(11) GENERATED ALWAYS AS ((`a` + `b`)) VIRTUAL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

POS:
    Column c is int (LEN = 4, MTYPE = 6), According to the formula ((nth virtual generated column for the InnoDB instance + 1) << 16) + the ordinal position of the generated virtual column. 
    It's the 1st (starts from 0) virtual column, and the 3rd (starts from 0) column; 
    So it's POS = (0 + 1) << 16 + 2 = 65538
    
PRTYPE:
    tinyint     = 1025
    smallint    = 1026
    mediumint   = 1033
    int         = 1027
    bigint      = 1032

    a:  int(1027) + DATA_NOT_NULL(256)      = 1283
    b:  int(1027)                           = 1027
    c:  int(1027) + DATA_VIRTUAL(8192)      = 9219
```
The virtual column’s metadata information is stored in the InnoDB SYS_COLUMNS system table along with other columns, the only difference being that its ‘PRTYPE’ value has an additional DATA_VIRTUAL (8192) bit set on it.


### INFORMATION_SCHEMA.INNODB_SYS_VIRTUAL
```
db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_VIRTUAL;
+----------+-------+----------+
| TABLE_ID | POS   | BASE_POS
+----------+-------+----------+
|       46 | 65538 |        0
|       46 | 65538 |        1
+----------+-------+----------+
```
In the above example, the ‘POS’ column represents the virtual column’s ‘POS’ value (in this case, column ‘c’) in SYS_COLUMNS, and ‘BASE_POS’ represents the base column’s ‘POS’ value in SYS_COLUMNS (0 for column ‘a’ and 1 for column ‘b’). Currently, the “base column” can only consist of standard materialized columns and cannot be other Generated Columns.

Even though the virtual columns are added to system tables similarly to other standard columns, they are represented in a separate domain than normal columns for the in-memory metadata.

With these designs, virtual columns can be added and dropped easily and without the need for a full table rebuild. This makes related table schema changes very simple and very fast.

```
db> ALTER TABLE t ADD new_col INT GENERATED ALWAYS AS (a - b) VIRTUAL;
db> SELECT * FROM t;
+----+------+------+---------+
| a  | b    | c    | new_col
+----+------+------+---------+
| 11 |    3 |   14 |       8
+----+------+------+---------+
```

# Creating Indexes on Non-Materialized Virtual Columns <a id="Creating_Indexes_on_NonMaterialized_Virtual_Columns"></a>
We can create secondary indexes on the virtual columns! Once a secondary index has been created on the virtual column, the virtual column data is then essentially materialized and stored in the secondary index records. This means that the virtual column’s value does not need to be calculated when the virtual column is queried. Again, this makes them effectively a functional index or function-based index.

## Virtual index creation
```
db> CREATE INDEX idx ON t(c);
```

### INFORMATION_SCHEMA.INNODB_SYS_INDEXES and INFORMATION_SCHEMA.INNODB_SYS_FILEDS
Now the new ‘idx’ index has been added to the SYS_INDEXES system table, and the virtual column ‘c’ has been added to SYS_FIELDS system table:
```
db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES;
+----------+-----------------------+----------+------+----------+---------+-------+-----------------
| INDEX_ID | NAME                  | TABLE_ID | TYPE | N_FIELDS | PAGE_NO | SPACE | MERGE_THRESHOLD 
+----------+-----------------------+----------+------+----------+---------+-------+-----------------
|       11 | ID_IND                |       11 |    3 |        1 |     270 |     0 |              50 
|       12 | FOR_IND               |       11 |    0 |        1 |     271 |     0 |              50 
|       13 | REF_IND               |       11 |    0 |        1 |     272 |     0 |              50 
|       14 | ID_IND                |       12 |    3 |        2 |     273 |     0 |              50 
|       15 | SYS_TABLESPACES_SPACE |       13 |    3 |        1 |     275 |     0 |              50
|       16 | SYS_DATAFILES_SPACE   |       14 |    3 |        1 |     276 |     0 |              50 
|       17 | BASE_IDX              |       15 |    3 |        3 |     278 |     0 |              50
|       18 | PRIMARY               |       16 |    3 |        1 |       3 |     2 |              50 
|       19 | PRIMARY               |       17 |    3 |        1 |       3 |     3 |              50 
|       31 | PRIMARY               |       26 |    3 |        1 |       3 |    12 |              50 
|       32 | PRIMARY               |       27 |    3 |        2 |       3 |    13 |              50 
|       33 | PRIMARY               |       28 |    3 |        4 |       3 |    14 |              50 
|       34 | PRIMARY               |       29 |    3 |        1 |       3 |    15 |              50
|       35 | PRIMARY               |       30 |    3 |        1 |       3 |    16 |              50 
|       36 | PRIMARY               |       31 |    3 |        2 |       3 |    17 |              50
|       37 | PRIMARY               |       32 |    3 |        2 |       3 |    18 |              50
|       38 | PRIMARY               |       33 |    3 |        1 |       3 |    19 |              50
|       39 | PRIMARY               |       34 |    3 |        3 |       3 |    20 |              50
|       20 | PRIMARY               |       35 |    3 |        1 |       3 |     4 |              50
|       21 | name                  |       35 |    2 |        1 |       4 |     4 |              50
|       22 | PRIMARY               |       36 |    3 |        1 |       3 |     5 |              50
|       23 | name                  |       36 |    2 |        1 |       4 |     5 |              50
|       25 | PRIMARY               |       37 |    3 |        1 |       3 |     7 |              50
|       26 | name                  |       37 |    2 |        1 |       4 |     7 |              50
|       24 | PRIMARY               |       38 |    3 |        2 |       3 |     6 |              50
|       40 | PRIMARY               |       39 |    3 |        1 |       3 |    21 |              50
|       28 | PRIMARY               |       40 |    3 |        1 |       3 |     9 |              50
|       27 | PRIMARY               |       41 |    3 |        1 |       3 |     8 |              50
|       29 | PRIMARY               |       42 |    3 |        2 |       3 |    10 |              50
|       30 | PRIMARY               |       43 |    3 |        2 |       3 |    11 |              50
|       44 | PRIMARY               |       46 |    3 |        1 |       3 |    38 |              50
|       51 | idx                   |       46 |  128 |        1 |       4 |    38 |              50
|       50 | GEN_CLUST_INDEX       |       52 |    1 |        0 |       3 |    44 |              50
+----------+-----------------------+----------+------+----------+---------+-------+-----------------

db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FIELDS;
+----------+--------------------+-----+
| INDEX_ID | NAME               | POS |
+----------+--------------------+-----+
|       11 | ID                 |   0 |
|       12 | FOR_NAME           |   0 |
|       13 | REF_NAME           |   0 |
|       14 | ID                 |   0 |
|       14 | POS                |   1 |
|       15 | SPACE              |   0 |
|       16 | SPACE              |   0 |
|       17 | TABLE_ID           |   0 |
|       17 | POS                |   1 |
|       17 | BASE_POS           |   2 |
|       18 | name               |   0 |
|       19 | Server_name        |   0 |
|       20 | help_topic_id      |   0 |
|       21 | name               |   0 |
|       22 | help_category_id   |   0 |
|       23 | name               |   0 |
|       24 | help_keyword_id    |   0 |
|       24 | help_topic_id      |   1 |
|       25 | help_keyword_id    |   0 |
|       26 | name               |   0 |
|       27 | Name               |   0 |
|       28 | Time_zone_id       |   0 |
|       29 | Time_zone_id       |   0 |
|       29 | Transition_time    |   1 |
|       30 | Time_zone_id       |   0 |
|       30 | Transition_type_id |   1 |
|       31 | Transition_time    |   0 |
|       32 | database_name      |   0 |
|       32 | table_name         |   1 |
|       33 | database_name      |   0 |
|       33 | table_name         |   1 |
|       33 | index_name         |   2 |
|       33 | stat_name          |   3 |
|       34 | Channel_name       |   0 |
|       35 | Channel_name       |   0 |
|       36 | Channel_name       |   0 |
|       36 | Id                 |   1 |
|       37 | source_uuid        |   0 |
|       37 | interval_start     |   1 |
|       38 | cost_name          |   0 |
|       39 | cost_name          |   0 |
|       39 | engine_name        |   1 |
|       39 | device_type        |   2 |
|       40 | variable           |   0 |
|       44 | a                  |   0 |
|       51 | c                  |   0 |
+----------+--------------------+-----+


db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE TABLE_ID = (
        SELECT TABLE_ID FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME = 'aa_tests/t' LIMIT 1
    );
+----------+---------+----------+------+----------+---------+-------+-----------------+
| INDEX_ID | NAME    | TABLE_ID | TYPE | N_FIELDS | PAGE_NO | SPACE | MERGE_THRESHOLD |
+----------+---------+----------+------+----------+---------+-------+-----------------+
|       44 | PRIMARY |       46 |    3 |        1 |       3 |    38 |              50 |
|       51 | idx     |       46 |  128 |        1 |       4 |    38 |              50 |
+----------+---------+----------+------+----------+---------+-------+-----------------+


db> SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FIELDS WHERE INDEX_ID IN (
        SELECT INDEX_ID FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE INDEX_ID = 44 OR INDEX_ID = 51
    );
+----------+------+-----+
| INDEX_ID | NAME | POS |
+----------+------+-----+
|       44 | a    |   0 |
|       51 | c    |   0 |
+----------+------+-----+
```
## DML(INSERT, UPDATE, DELETE) to Virtual Columns
You cannot INSERT or UPDATE values for any virtual column directly. Instead, the INSERT and UPDATE operations for them are performed indirectly through any changes to the base columns.
```
db> SELECT * FROM t;
+----+------+------+---------+
| a  | b    | c    | new_col |
+----+------+------+---------+
| 11 |    3 |   14 |       8 |
+----+------+------+---------+

db> UPDATE t SET a = 20;
+----+------+------+---------+
| a  | b    | c    | new_col |
+----+------+------+---------+
| 20 |    3 |   23 |      17 |
+----+------+------+---------+

db> EXPLAIN SELECT c FROM t;
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t     | NULL       | index | NULL          | idx  | 5       | NULL |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-------------+
```
One thing to note here is that we do log virtual column DMLs so that such data changes may not need to be recalculated for MVCC, crash recovery, and/or UNDO operations. Of course, only operations on those indexed virtual columns are logged. 

# Query Using A Funcional Index With JSON/XML/Geo/String <a id="Query_Using_A_Funcional_Index_With_JSON_XML_Geo_String"></a>
With a “functional index” on virtual columns, a user is now able to search qualified rows using both non-covered and covered scans. The “functional index” can be queried, and depending on the scenario (isolation level etc.), the clustered index can be subsequently consulted.

Queries on virtual columns also support MVCC, since we log the updates on the virtual column in the UNDO log. However, there are maximum index size limitations to consider—767 bytes for COMPACT/REDUNDANT ROW formats or 3072 bytes for COMPRESSED/DYNAMIC ROW formats. If the queried object has a longer length, then the value will have to be generated from the base column(s) on the fly.

The query would also support all isolation levels, which means that you can also place GAP locks on the indexed virtual columns in certain situations.

In addition, the “functional index” also supports prefix indexes as well as unique indexes. 

## Indexes on JSON fields

```
db> create table employees(id bigint not null primary key auto_increment, info JSON);
db> insert into employees (info) values ('{ "name": "Aario Ai", "age": 18, "Duties": { "Product Manager": ["stuff", "more stuff"]} }');
db> select json_type(info) from employees;
+-----------------+
| json_type(info) |
+-----------------+
| OBJECT          |
+-----------------+

db> select id, json_extract(info, '$.name') from employees;
db> alter table employees add name varchar(100) generated always as (json_extract(info, '$.name')) virtual;
db> alter table employees add index(name);
db> show create table employees \G
*************************** 1. row ***************************
       Table: employees
Create Table: CREATE TABLE `employees` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `info` json DEFAULT NULL,
  `name` varchar(100) COLLATE utf8mb4_unicode_ci GENERATED ALWAYS AS (json_extract(`info`,'$.name')) VIRTUAL,
  PRIMARY KEY (`id`),
  KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci


db> explain select id, name from employees where name = 'Aario Ai';
+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ref  | name          | name | 403     | const |    1 |   100.00 | Using index |
+----+-------------+-----------+------------+------+---------------+------+---------+-------+------+----------+-------------+

db> explain format=JSON select id, name from employees where name = 'Aario Ai';
*************************** 1. row ***************************
EXPLAIN: {
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "1.20"
    },
    "table": {
      "table_name": "employees",
      "access_type": "ref",
      "possible_keys": [
        "name"
      ],
      "key": "name",
      "used_key_parts": [
        "name"
      ],
      "key_length": "403",
      "ref": [
        "const"
      ],
      "rows_examined_per_scan": 1,
      "rows_produced_per_join": 1,
      "filtered": "100.00",
      "using_index": true,
      "cost_info": {
        "read_cost": "1.00",
        "eval_cost": "0.20",
        "prefix_cost": "1.20",
        "data_read_per_join": "424"
      },
      "used_columns": [
        "id",
        "info",
        "name"
      ]
    }
  }
}
```

## Indexes on XML fields
```
db> create table t(a int, b varchar(100), c varchar(100) generated always as (ExtractValue(b, '//name[1]')) virtual);
db> insert into t values (1, '<User><name>Aario</name><name>艾睿</name></User>', default);
db> select * from t;
+------+----------------------------------------------------+-------+
| a    | b                                                  | c     |
+------+----------------------------------------------------+-------+
|    1 | <User><name>Aario</name><name>艾睿</name></User>   | Aario |
+------+----------------------------------------------------+-------+
```

## Indexes on Geometry Calculation
> geometry  Point($lon, $lat)
```
db> create table t (
        id int(11) unsigned not null auto_increment,
        prov varchar(20) not null default '',
        city varchar(20) not null default '',
        coord geometry default null,
        north_coord geometry default null,
        south_coord geometry default null,
        primary key (`id`)
    ) ENGINE=InnoDB;
    
db> insert into t (prov, city, coord, north_coord, south_coord) values (
        'Guangdong', 'Guangzhou', Point(113.2278442, 23.1255978), Point(113.2541171, 23.3012045), Point(113.3102416, 22.8913576)
    );
db> insert into t (prov, city, coord, north_coord, south_coord) values (
        'Guangdong', 'Shenzhen', Point(114.0538788, 22.5551603), Point(114.0394592, 22.6837170), Point(114.0566253, 22.5005043)
    );
    
db> alter table t add distance double generated always as (st_distance_sphere(north_coord, south_coord)) virtual;
db> create index idx on t(distance);
db> explain select distance from t\G
```

## Indexes on String Manipulation
```
db> create table t (
        a varchar(100) not null default '',
        b varchar(100) not null default ''
    ) ENGINE=InnoDB;
db> insert into t values('Aario', 'Ai');
db> alter table t add column len int unsigned generated always as (char_length(a) + char_length(b)) virtual;
db> alter table t add column pos_i int unsigned generated always as (instr(a, 'i')) virtual;
db> select * from t;
+-------+----+------+-------+
| a     | b  | len  | pos_i |
+-------+----+------+-------+
| Aario | Ai |    7 |     4 |
+-------+----+------+-------+
```

# Quick Performance Benchmarks <a id="Quick_Performance_Benchmarks"></a>
As expected, there will be some additional write cost when using an index on a virtual column due to the necessary computation of the virtual columns when they need to be materialized (e.g. INSERT or UPDATE), in other words the costs will be associated with creating and maintaining the index. If the column does not have a functional index, however, then the cost will instead be associated with reads as the value will need to be materialized any time that the row is examined. The added cost is also directly related to the complexity of the computation functions used.

However, even with such additional costs, using virtual columns and “functional indexes” can still be far better than creating the table with such STORED generated columns as the latter materialize the data in the clustered index (primary key), thus resulting in a larger table (both on disk and in memory).


```
db> CREATE TABLE `t` (      /* A table with virtual columns: */
        `h` INT NOT NULL PRIMARY KEY,
        `a` varchar(30),
        `b` BLOB,
        `v_a_b` BLOB GENERATED ALWAYS AS (CONCAT(a,b)) VIRTUAL,
        `v_b` BLOB GENERATED ALWAYS AS (b) VIRTUAL,
        `e` int,
        `v_h_e` INT(11) GENERATED ALWAYS AS (h + e) VIRTUAL,
        `v_e` INT GENERATED ALWAYS AS (e) VIRTUAL,
        `v_a` INT GENERATED ALWAYS AS (char_length(a)) VIRTUAL
    ) ENGINE=InnoDB;

db> CREATE TABLE `t_nv` (   /* A “normal” table without a any generated columns at all (neither VIRTUAL or STORED): */
        `h` INT NOT NULL PRIMARY KEY,
        `a` VARCHAR(30),
        `b` BLOB,
        `e` INT
    ) ENGINE=InnoDB;
    
db> CREATE TABLE `t_m` (    /* A table with materialized or STORED generated columns */
        `h` INT NOT NULL PRIMARY KEY,
        `a` varchar(30),
        `b` BLOB,
        `v_a_b` BLOB GENERATED ALWAYS AS (CONCAT(a,b)) STORED,
        `v_b` BLOB GENERATED ALWAYS AS (b) STORED,
        `e` int,
        `v_h_e` INT(11) GENERATED ALWAYS AS (h + e) STORED,
        `v_e` INT GENERATED ALWAYS AS (e) STORED,
        `v_a` INT GENERATED ALWAYS AS (char_length(a)) STORED
    ) ENGINE=InnoDB;
    
db> DELIMITER $$
    CREATE PROCEDURE insert_values(n1 int, n2 int)          /* procedure to INSERT rows into each of these tables */
    BEGIN
        DECLARE i INT DEFAULT 1;
        WHILE (i+n1 <= 100000+n2) DO
                INSERT INTO t VALUES (n1+i, CAST(n1+i AS CHAR), REPEAT('b', 2000), DEFAULT, DEFAULT, n1+i+10, DEFAULT, DEFAULT, DEFAULT);
                INSERT INTO t_nv VALUES (n1+i, CAST(n1+i AS CHAR),  REPEAT('b', 2000), n1+i+10);
                INSERT INTO t_m VALUES (n1+i, CAST(n1+i AS CHAR), REPEAT('b', 2000), DEFAULT, DEFAULT, n1+i+10, DEFAULT, DEFAULT, DEFAULT);
                SET i = i + 1;
        END WHILE;
    END
    $$
    DELIMITER ;
```

All tests were conducted on a 48 core x86_64 GNU/Linux machine, with a 10GB InnoDB buffer pool. All tests were run with a single thread. Each number comes from averages of over 3 runs. Here are the results:

```
+-----------------------------------------------------------------------+
|                    Insertion without an index                         |
+--------------------+------------------------+-------------------------+
|                    | Insert of 500,000 row  | Insert of 1,000,000 row |
+--------------------+------------------------+-------------------------+
| t (with virtual)   |    3 min 24.65 sec     |      6 min 59.91 sec    |
+--------------------+------------------------+-------------------------+
| t_nv (no virtual)  |    3 min 21.41 sec     |      6 min 31.82 sec    |
+--------------------+------------------------+-------------------------+
| t_m (with stored)  |     4 min 25.58 sec    |      8 min 43.66 sec    |
+--------------------+------------------------+-------------------------+
|         Create Index to 1,000,000 row       |
+--------------------+------------------------+
| t (with virtual)   |        2.90 sec 
+--------------------+------------------------+
| t_nv (no virtual)  |        2.40 sec 
+--------------------+------------------------+
| t_m (with stored)  |        3.31 sec        
+--------------------+------------------------+